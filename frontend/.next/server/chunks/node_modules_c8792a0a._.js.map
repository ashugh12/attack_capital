{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/digest.js"],"sourcesContent":["import { createHash } from 'node:crypto';\nconst digest = (algorithm, data) => createHash(algorithm).update(data).digest();\nexport default digest;\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,SAAS,CAAC,WAAW,OAAS,IAAA,mIAAU,EAAC,WAAW,MAAM,CAAC,MAAM,MAAM;uCAC9D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/buffer_utils.js"],"sourcesContent":["import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    for (const buffer of buffers) {\n        buf.set(buffer, i);\n        i += buffer.length;\n    }\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;;AACO,MAAM,UAAU,IAAI;AACpB,MAAM,UAAU,IAAI;AAC3B,MAAM,YAAY,KAAK;AAChB,SAAS,OAAO,GAAG,OAAO;IAC7B,MAAM,OAAO,QAAQ,MAAM,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,GAAK,MAAM,QAAQ;IAC/D,MAAM,MAAM,IAAI,WAAW;IAC3B,IAAI,IAAI;IACR,KAAK,MAAM,UAAU,QAAS;QAC1B,IAAI,GAAG,CAAC,QAAQ;QAChB,KAAK,OAAO,MAAM;IACtB;IACA,OAAO;AACX;AACO,SAAS,IAAI,GAAG,EAAE,QAAQ;IAC7B,OAAO,OAAO,QAAQ,MAAM,CAAC,MAAM,IAAI,WAAW;QAAC;KAAE,GAAG;AAC5D;AACA,SAAS,cAAc,GAAG,EAAE,KAAK,EAAE,MAAM;IACrC,IAAI,QAAQ,KAAK,SAAS,WAAW;QACjC,MAAM,IAAI,WAAW,CAAC,0BAA0B,EAAE,YAAY,EAAE,WAAW,EAAE,OAAO;IACxF;IACA,IAAI,GAAG,CAAC;QAAC,UAAU;QAAI,UAAU;QAAI,UAAU;QAAG,QAAQ;KAAK,EAAE;AACrE;AACO,SAAS,SAAS,KAAK;IAC1B,MAAM,OAAO,KAAK,KAAK,CAAC,QAAQ;IAChC,MAAM,MAAM,QAAQ;IACpB,MAAM,MAAM,IAAI,WAAW;IAC3B,cAAc,KAAK,MAAM;IACzB,cAAc,KAAK,KAAK;IACxB,OAAO;AACX;AACO,SAAS,SAAS,KAAK;IAC1B,MAAM,MAAM,IAAI,WAAW;IAC3B,cAAc,KAAK;IACnB,OAAO;AACX;AACO,SAAS,eAAe,KAAK;IAChC,OAAO,OAAO,SAAS,MAAM,MAAM,GAAG;AAC1C;AACO,eAAe,UAAU,MAAM,EAAE,IAAI,EAAE,KAAK;IAC/C,MAAM,aAAa,KAAK,IAAI,CAAC,CAAC,QAAQ,CAAC,IAAI;IAC3C,MAAM,MAAM,IAAI,WAAW,aAAa;IACxC,IAAK,IAAI,OAAO,GAAG,OAAO,YAAY,OAAQ;QAC1C,MAAM,MAAM,IAAI,WAAW,IAAI,OAAO,MAAM,GAAG,MAAM,MAAM;QAC3D,IAAI,GAAG,CAAC,SAAS,OAAO;QACxB,IAAI,GAAG,CAAC,QAAQ;QAChB,IAAI,GAAG,CAAC,OAAO,IAAI,OAAO,MAAM;QAChC,IAAI,GAAG,CAAC,MAAM,IAAA,6KAAM,EAAC,UAAU,MAAM,OAAO;IAChD;IACA,OAAO,IAAI,KAAK,CAAC,GAAG,QAAQ;AAChC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/base64url.js"],"sourcesContent":["import { Buffer } from 'node:buffer';\nimport { decoder } from '../lib/buffer_utils.js';\nfunction normalize(input) {\n    let encoded = input;\n    if (encoded instanceof Uint8Array) {\n        encoded = decoder.decode(encoded);\n    }\n    return encoded;\n}\nconst encode = (input) => Buffer.from(input).toString('base64url');\nexport const decodeBase64 = (input) => new Uint8Array(Buffer.from(input, 'base64'));\nexport const encodeBase64 = (input) => Buffer.from(input).toString('base64');\nexport { encode };\nexport const decode = (input) => new Uint8Array(Buffer.from(normalize(input), 'base64url'));\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AACA,SAAS,UAAU,KAAK;IACpB,IAAI,UAAU;IACd,IAAI,mBAAmB,YAAY;QAC/B,UAAU,+KAAO,CAAC,MAAM,CAAC;IAC7B;IACA,OAAO;AACX;AACA,MAAM,SAAS,CAAC,QAAU,+HAAM,CAAC,IAAI,CAAC,OAAO,QAAQ,CAAC;AAC/C,MAAM,eAAe,CAAC,QAAU,IAAI,WAAW,+HAAM,CAAC,IAAI,CAAC,OAAO;AAClE,MAAM,eAAe,CAAC,QAAU,+HAAM,CAAC,IAAI,CAAC,OAAO,QAAQ,CAAC;;AAE5D,MAAM,SAAS,CAAC,QAAU,IAAI,WAAW,+HAAM,CAAC,IAAI,CAAC,UAAU,QAAQ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/util/errors.js"],"sourcesContent":["export class JOSEError extends Error {\n    static code = 'ERR_JOSE_GENERIC';\n    code = 'ERR_JOSE_GENERIC';\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class JWTClaimValidationFailed extends JOSEError {\n    static code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JWTExpired extends JOSEError {\n    static code = 'ERR_JWT_EXPIRED';\n    code = 'ERR_JWT_EXPIRED';\n    claim;\n    reason;\n    payload;\n    constructor(message, payload, claim = 'unspecified', reason = 'unspecified') {\n        super(message, { cause: { claim, reason, payload } });\n        this.claim = claim;\n        this.reason = reason;\n        this.payload = payload;\n    }\n}\nexport class JOSEAlgNotAllowed extends JOSEError {\n    static code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n    code = 'ERR_JOSE_ALG_NOT_ALLOWED';\n}\nexport class JOSENotSupported extends JOSEError {\n    static code = 'ERR_JOSE_NOT_SUPPORTED';\n    code = 'ERR_JOSE_NOT_SUPPORTED';\n}\nexport class JWEDecryptionFailed extends JOSEError {\n    static code = 'ERR_JWE_DECRYPTION_FAILED';\n    code = 'ERR_JWE_DECRYPTION_FAILED';\n    constructor(message = 'decryption operation failed', options) {\n        super(message, options);\n    }\n}\nexport class JWEInvalid extends JOSEError {\n    static code = 'ERR_JWE_INVALID';\n    code = 'ERR_JWE_INVALID';\n}\nexport class JWSInvalid extends JOSEError {\n    static code = 'ERR_JWS_INVALID';\n    code = 'ERR_JWS_INVALID';\n}\nexport class JWTInvalid extends JOSEError {\n    static code = 'ERR_JWT_INVALID';\n    code = 'ERR_JWT_INVALID';\n}\nexport class JWKInvalid extends JOSEError {\n    static code = 'ERR_JWK_INVALID';\n    code = 'ERR_JWK_INVALID';\n}\nexport class JWKSInvalid extends JOSEError {\n    static code = 'ERR_JWKS_INVALID';\n    code = 'ERR_JWKS_INVALID';\n}\nexport class JWKSNoMatchingKey extends JOSEError {\n    static code = 'ERR_JWKS_NO_MATCHING_KEY';\n    code = 'ERR_JWKS_NO_MATCHING_KEY';\n    constructor(message = 'no applicable key found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSMultipleMatchingKeys extends JOSEError {\n    [Symbol.asyncIterator];\n    static code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';\n    constructor(message = 'multiple matching keys found in the JSON Web Key Set', options) {\n        super(message, options);\n    }\n}\nexport class JWKSTimeout extends JOSEError {\n    static code = 'ERR_JWKS_TIMEOUT';\n    code = 'ERR_JWKS_TIMEOUT';\n    constructor(message = 'request timed out', options) {\n        super(message, options);\n    }\n}\nexport class JWSSignatureVerificationFailed extends JOSEError {\n    static code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';\n    constructor(message = 'signature verification failed', options) {\n        super(message, options);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,kBAAkB;IAC3B,OAAO,OAAO,mBAAmB;IACjC,OAAO,mBAAmB;IAC1B,YAAY,OAAO,EAAE,OAAO,CAAE;QAC1B,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI;QACjC,MAAM,iBAAiB,GAAG,IAAI,EAAE,IAAI,CAAC,WAAW;IACpD;AACJ;AACO,MAAM,iCAAiC;IAC1C,OAAO,OAAO,kCAAkC;IAChD,OAAO,kCAAkC;IACzC,MAAM;IACN,OAAO;IACP,QAAQ;IACR,YAAY,OAAO,EAAE,OAAO,EAAE,QAAQ,aAAa,EAAE,SAAS,aAAa,CAAE;QACzE,KAAK,CAAC,SAAS;YAAE,OAAO;gBAAE;gBAAO;gBAAQ;YAAQ;QAAE;QACnD,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;IACnB;AACJ;AACO,MAAM,mBAAmB;IAC5B,OAAO,OAAO,kBAAkB;IAChC,OAAO,kBAAkB;IACzB,MAAM;IACN,OAAO;IACP,QAAQ;IACR,YAAY,OAAO,EAAE,OAAO,EAAE,QAAQ,aAAa,EAAE,SAAS,aAAa,CAAE;QACzE,KAAK,CAAC,SAAS;YAAE,OAAO;gBAAE;gBAAO;gBAAQ;YAAQ;QAAE;QACnD,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;IACnB;AACJ;AACO,MAAM,0BAA0B;IACnC,OAAO,OAAO,2BAA2B;IACzC,OAAO,2BAA2B;AACtC;AACO,MAAM,yBAAyB;IAClC,OAAO,OAAO,yBAAyB;IACvC,OAAO,yBAAyB;AACpC;AACO,MAAM,4BAA4B;IACrC,OAAO,OAAO,4BAA4B;IAC1C,OAAO,4BAA4B;IACnC,YAAY,UAAU,6BAA6B,EAAE,OAAO,CAAE;QAC1D,KAAK,CAAC,SAAS;IACnB;AACJ;AACO,MAAM,mBAAmB;IAC5B,OAAO,OAAO,kBAAkB;IAChC,OAAO,kBAAkB;AAC7B;AACO,MAAM,mBAAmB;IAC5B,OAAO,OAAO,kBAAkB;IAChC,OAAO,kBAAkB;AAC7B;AACO,MAAM,mBAAmB;IAC5B,OAAO,OAAO,kBAAkB;IAChC,OAAO,kBAAkB;AAC7B;AACO,MAAM,mBAAmB;IAC5B,OAAO,OAAO,kBAAkB;IAChC,OAAO,kBAAkB;AAC7B;AACO,MAAM,oBAAoB;IAC7B,OAAO,OAAO,mBAAmB;IACjC,OAAO,mBAAmB;AAC9B;AACO,MAAM,0BAA0B;IACnC,OAAO,OAAO,2BAA2B;IACzC,OAAO,2BAA2B;IAClC,YAAY,UAAU,iDAAiD,EAAE,OAAO,CAAE;QAC9E,KAAK,CAAC,SAAS;IACnB;AACJ;AACO,MAAM,iCAAiC;IAC1C,CAAC,OAAO,aAAa,CAAC,CAAC;IACvB,OAAO,OAAO,kCAAkC;IAChD,OAAO,kCAAkC;IACzC,YAAY,UAAU,sDAAsD,EAAE,OAAO,CAAE;QACnF,KAAK,CAAC,SAAS;IACnB;AACJ;AACO,MAAM,oBAAoB;IAC7B,OAAO,OAAO,mBAAmB;IACjC,OAAO,mBAAmB;IAC1B,YAAY,UAAU,mBAAmB,EAAE,OAAO,CAAE;QAChD,KAAK,CAAC,SAAS;IACnB;AACJ;AACO,MAAM,uCAAuC;IAChD,OAAO,OAAO,wCAAwC;IACtD,OAAO,wCAAwC;IAC/C,YAAY,UAAU,+BAA+B,EAAE,OAAO,CAAE;QAC5D,KAAK,CAAC,SAAS;IACnB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/dsa_digest.js"],"sourcesContent":["import { JOSENotSupported } from '../util/errors.js';\nexport default function dsaDigest(alg) {\n    switch (alg) {\n        case 'PS256':\n        case 'RS256':\n        case 'ES256':\n        case 'ES256K':\n            return 'sha256';\n        case 'PS384':\n        case 'RS384':\n        case 'ES384':\n            return 'sha384';\n        case 'PS512':\n        case 'RS512':\n        case 'ES512':\n            return 'sha512';\n        case 'Ed25519':\n        case 'EdDSA':\n            return undefined;\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACe,SAAS,UAAU,GAAG;IACjC,OAAQ;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;QACL,KAAK;YACD,OAAO;QACX,KAAK;QACL,KAAK;YACD,OAAO;QACX;YACI,MAAM,IAAI,mLAAgB,CAAC,CAAC,IAAI,EAAE,IAAI,2DAA2D,CAAC;IAC1G;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/hmac_digest.js"],"sourcesContent":["import { JOSENotSupported } from '../util/errors.js';\nexport default function hmacDigest(alg) {\n    switch (alg) {\n        case 'HS256':\n            return 'sha256';\n        case 'HS384':\n            return 'sha384';\n        case 'HS512':\n            return 'sha512';\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACe,SAAS,WAAW,GAAG;IAClC,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,MAAM,IAAI,mLAAgB,CAAC,CAAC,IAAI,EAAE,IAAI,2DAA2D,CAAC;IAC1G;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/webcrypto.js"],"sourcesContent":["import * as crypto from 'node:crypto';\nimport * as util from 'node:util';\nconst webcrypto = crypto.webcrypto;\nexport default webcrypto;\nexport const isCryptoKey = (key) => util.types.isCryptoKey(key);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACA,MAAM,YAAY,kIAAgB;uCACnB;AACR,MAAM,cAAc,CAAC,MAAQ,0HAAU,CAAC,WAAW,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 345, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/is_key_object.js"],"sourcesContent":["import * as util from 'node:util';\nexport default (obj) => util.types.isKeyObject(obj);\n"],"names":[],"mappings":";;;;AAAA;;uCACe,CAAC,MAAQ,0HAAU,CAAC,WAAW,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 356, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/invalid_key_input.js"],"sourcesContent":["function message(msg, actual, ...types) {\n    types = types.filter(Boolean);\n    if (types.length > 2) {\n        const last = types.pop();\n        msg += `one of type ${types.join(', ')}, or ${last}.`;\n    }\n    else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}.`;\n    }\n    else {\n        msg += `of type ${types[0]}.`;\n    }\n    if (actual == null) {\n        msg += ` Received ${actual}`;\n    }\n    else if (typeof actual === 'function' && actual.name) {\n        msg += ` Received function ${actual.name}`;\n    }\n    else if (typeof actual === 'object' && actual != null) {\n        if (actual.constructor?.name) {\n            msg += ` Received an instance of ${actual.constructor.name}`;\n        }\n    }\n    return msg;\n}\nexport default (actual, ...types) => {\n    return message('Key must be ', actual, ...types);\n};\nexport function withAlg(alg, actual, ...types) {\n    return message(`Key for the ${alg} algorithm must be `, actual, ...types);\n}\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,QAAQ,GAAG,EAAE,MAAM,EAAE,GAAG,KAAK;IAClC,QAAQ,MAAM,MAAM,CAAC;IACrB,IAAI,MAAM,MAAM,GAAG,GAAG;QAClB,MAAM,OAAO,MAAM,GAAG;QACtB,OAAO,CAAC,YAAY,EAAE,MAAM,IAAI,CAAC,MAAM,KAAK,EAAE,KAAK,CAAC,CAAC;IACzD,OACK,IAAI,MAAM,MAAM,KAAK,GAAG;QACzB,OAAO,CAAC,YAAY,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;IACpD,OACK;QACD,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC;IACjC;IACA,IAAI,UAAU,MAAM;QAChB,OAAO,CAAC,UAAU,EAAE,QAAQ;IAChC,OACK,IAAI,OAAO,WAAW,cAAc,OAAO,IAAI,EAAE;QAClD,OAAO,CAAC,mBAAmB,EAAE,OAAO,IAAI,EAAE;IAC9C,OACK,IAAI,OAAO,WAAW,YAAY,UAAU,MAAM;QACnD,IAAI,OAAO,WAAW,EAAE,MAAM;YAC1B,OAAO,CAAC,yBAAyB,EAAE,OAAO,WAAW,CAAC,IAAI,EAAE;QAChE;IACJ;IACA,OAAO;AACX;uCACe,CAAC,QAAQ,GAAG;IACvB,OAAO,QAAQ,gBAAgB,WAAW;AAC9C;AACO,SAAS,QAAQ,GAAG,EAAE,MAAM,EAAE,GAAG,KAAK;IACzC,OAAO,QAAQ,CAAC,YAAY,EAAE,IAAI,mBAAmB,CAAC,EAAE,WAAW;AACvE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/is_key_like.js"],"sourcesContent":["import webcrypto, { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nexport default (key) => isKeyObject(key) || isCryptoKey(key);\nconst types = ['KeyObject'];\nif (globalThis.CryptoKey || webcrypto?.CryptoKey) {\n    types.push('CryptoKey');\n}\nexport { types };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;uCACe,CAAC,MAAQ,IAAA,oLAAW,EAAC,QAAQ,IAAA,oLAAW,EAAC;AACxD,MAAM,QAAQ;IAAC;CAAY;AAC3B,IAAI,WAAW,SAAS,IAAI,gLAAS,EAAE,WAAW;IAC9C,MAAM,IAAI,CAAC;AACf","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/is_object.js"],"sourcesContent":["function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport default function isObject(input) {\n    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(input) === null) {\n        return true;\n    }\n    let proto = input;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(input) === proto;\n}\n"],"names":[],"mappings":";;;;AAAA,SAAS,aAAa,KAAK;IACvB,OAAO,OAAO,UAAU,YAAY,UAAU;AAClD;AACe,SAAS,SAAS,KAAK;IAClC,IAAI,CAAC,aAAa,UAAU,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,mBAAmB;QACrF,OAAO;IACX;IACA,IAAI,OAAO,cAAc,CAAC,WAAW,MAAM;QACvC,OAAO;IACX;IACA,IAAI,QAAQ;IACZ,MAAO,OAAO,cAAc,CAAC,WAAW,KAAM;QAC1C,QAAQ,OAAO,cAAc,CAAC;IAClC;IACA,OAAO,OAAO,cAAc,CAAC,WAAW;AAC5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 439, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/is_jwk.js"],"sourcesContent":["import isObject from './is_object.js';\nexport function isJWK(key) {\n    return isObject(key) && typeof key.kty === 'string';\n}\nexport function isPrivateJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'string';\n}\nexport function isPublicJWK(key) {\n    return key.kty !== 'oct' && typeof key.d === 'undefined';\n}\nexport function isSecretJWK(key) {\n    return isJWK(key) && key.kty === 'oct' && typeof key.k === 'string';\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACO,SAAS,MAAM,GAAG;IACrB,OAAO,IAAA,4KAAQ,EAAC,QAAQ,OAAO,IAAI,GAAG,KAAK;AAC/C;AACO,SAAS,aAAa,GAAG;IAC5B,OAAO,IAAI,GAAG,KAAK,SAAS,OAAO,IAAI,CAAC,KAAK;AACjD;AACO,SAAS,YAAY,GAAG;IAC3B,OAAO,IAAI,GAAG,KAAK,SAAS,OAAO,IAAI,CAAC,KAAK;AACjD;AACO,SAAS,YAAY,GAAG;IAC3B,OAAO,MAAM,QAAQ,IAAI,GAAG,KAAK,SAAS,OAAO,IAAI,CAAC,KAAK;AAC/D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/get_named_curve.js"],"sourcesContent":["import { KeyObject } from 'node:crypto';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nimport { isJWK } from '../lib/is_jwk.js';\nexport const weakMap = new WeakMap();\nconst namedCurveToJOSE = (namedCurve) => {\n    switch (namedCurve) {\n        case 'prime256v1':\n            return 'P-256';\n        case 'secp384r1':\n            return 'P-384';\n        case 'secp521r1':\n            return 'P-521';\n        case 'secp256k1':\n            return 'secp256k1';\n        default:\n            throw new JOSENotSupported('Unsupported key curve for this operation');\n    }\n};\nconst getNamedCurve = (kee, raw) => {\n    let key;\n    if (isCryptoKey(kee)) {\n        key = KeyObject.from(kee);\n    }\n    else if (isKeyObject(kee)) {\n        key = kee;\n    }\n    else if (isJWK(kee)) {\n        return kee.crv;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(kee, ...types));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError('only \"private\" or \"public\" type keys can be used for this operation');\n    }\n    switch (key.asymmetricKeyType) {\n        case 'ed25519':\n        case 'ed448':\n            return `Ed${key.asymmetricKeyType.slice(2)}`;\n        case 'x25519':\n        case 'x448':\n            return `X${key.asymmetricKeyType.slice(1)}`;\n        case 'ec': {\n            const namedCurve = key.asymmetricKeyDetails.namedCurve;\n            if (raw) {\n                return namedCurve;\n            }\n            return namedCurveToJOSE(namedCurve);\n        }\n        default:\n            throw new TypeError('Invalid asymmetric key type for this operation');\n    }\n};\nexport default getNamedCurve;\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACO,MAAM,UAAU,IAAI;AAC3B,MAAM,mBAAmB,CAAC;IACtB,OAAQ;QACJ,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX,KAAK;YACD,OAAO;QACX;YACI,MAAM,IAAI,mLAAgB,CAAC;IACnC;AACJ;AACA,MAAM,gBAAgB,CAAC,KAAK;IACxB,IAAI;IACJ,IAAI,IAAA,oLAAW,EAAC,MAAM;QAClB,MAAM,kIAAS,CAAC,IAAI,CAAC;IACzB,OACK,IAAI,IAAA,oLAAW,EAAC,MAAM;QACvB,MAAM;IACV,OACK,IAAI,IAAA,uKAAK,EAAC,MAAM;QACjB,OAAO,IAAI,GAAG;IAClB,OACK;QACD,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,QAAQ,gLAAK;IACrD;IACA,IAAI,IAAI,IAAI,KAAK,UAAU;QACvB,MAAM,IAAI,UAAU;IACxB;IACA,OAAQ,IAAI,iBAAiB;QACzB,KAAK;QACL,KAAK;YACD,OAAO,CAAC,EAAE,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI;QAChD,KAAK;QACL,KAAK;YACD,OAAO,CAAC,CAAC,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI;QAC/C,KAAK;YAAM;gBACP,MAAM,aAAa,IAAI,oBAAoB,CAAC,UAAU;gBACtD,IAAI,KAAK;oBACL,OAAO;gBACX;gBACA,OAAO,iBAAiB;YAC5B;QACA;YACI,MAAM,IAAI,UAAU;IAC5B;AACJ;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 540, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/check_key_length.js"],"sourcesContent":["import { KeyObject } from 'node:crypto';\nexport default (key, alg) => {\n    let modulusLength;\n    try {\n        if (key instanceof KeyObject) {\n            modulusLength = key.asymmetricKeyDetails?.modulusLength;\n        }\n        else {\n            modulusLength = Buffer.from(key.n, 'base64url').byteLength << 3;\n        }\n    }\n    catch { }\n    if (typeof modulusLength !== 'number' || modulusLength < 2048) {\n        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);\n    }\n};\n"],"names":[],"mappings":";;;;AAAA;;uCACe,CAAC,KAAK;IACjB,IAAI;IACJ,IAAI;QACA,IAAI,eAAe,kIAAS,EAAE;YAC1B,gBAAgB,IAAI,oBAAoB,EAAE;QAC9C,OACK;YACD,gBAAgB,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,aAAa,UAAU,IAAI;QAClE;IACJ,EACA,OAAM,CAAE;IACR,IAAI,OAAO,kBAAkB,YAAY,gBAAgB,MAAM;QAC3D,MAAM,IAAI,UAAU,GAAG,IAAI,qDAAqD,CAAC;IACrF;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/node_key.js"],"sourcesContent":["import { constants, KeyObject } from 'node:crypto';\nimport getNamedCurve from './get_named_curve.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport checkKeyLength from './check_key_length.js';\nconst ecCurveAlgMap = new Map([\n    ['ES256', 'P-256'],\n    ['ES256K', 'secp256k1'],\n    ['ES384', 'P-384'],\n    ['ES512', 'P-521'],\n]);\nexport default function keyForCrypto(alg, key) {\n    let asymmetricKeyType;\n    let asymmetricKeyDetails;\n    let isJWK;\n    if (key instanceof KeyObject) {\n        asymmetricKeyType = key.asymmetricKeyType;\n        asymmetricKeyDetails = key.asymmetricKeyDetails;\n    }\n    else {\n        isJWK = true;\n        switch (key.kty) {\n            case 'RSA':\n                asymmetricKeyType = 'rsa';\n                break;\n            case 'EC':\n                asymmetricKeyType = 'ec';\n                break;\n            case 'OKP': {\n                if (key.crv === 'Ed25519') {\n                    asymmetricKeyType = 'ed25519';\n                    break;\n                }\n                if (key.crv === 'Ed448') {\n                    asymmetricKeyType = 'ed448';\n                    break;\n                }\n                throw new TypeError('Invalid key for this operation, its crv must be Ed25519 or Ed448');\n            }\n            default:\n                throw new TypeError('Invalid key for this operation, its kty must be RSA, OKP, or EC');\n        }\n    }\n    let options;\n    switch (alg) {\n        case 'Ed25519':\n            if (asymmetricKeyType !== 'ed25519') {\n                throw new TypeError(`Invalid key for this operation, its asymmetricKeyType must be ed25519`);\n            }\n            break;\n        case 'EdDSA':\n            if (!['ed25519', 'ed448'].includes(asymmetricKeyType)) {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');\n            }\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            if (asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');\n            }\n            checkKeyLength(key, alg);\n            break;\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            if (asymmetricKeyType === 'rsa-pss') {\n                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = asymmetricKeyDetails;\n                const length = parseInt(alg.slice(-3), 10);\n                if (hashAlgorithm !== undefined &&\n                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of \"alg\" ${alg}`);\n                }\n                if (saltLength !== undefined && saltLength > length >> 3) {\n                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of \"alg\" ${alg}`);\n                }\n            }\n            else if (asymmetricKeyType !== 'rsa') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');\n            }\n            checkKeyLength(key, alg);\n            options = {\n                padding: constants.RSA_PKCS1_PSS_PADDING,\n                saltLength: constants.RSA_PSS_SALTLEN_DIGEST,\n            };\n            break;\n        case 'ES256':\n        case 'ES256K':\n        case 'ES384':\n        case 'ES512': {\n            if (asymmetricKeyType !== 'ec') {\n                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');\n            }\n            const actual = getNamedCurve(key);\n            const expected = ecCurveAlgMap.get(alg);\n            if (actual !== expected) {\n                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);\n            }\n            options = { dsaEncoding: 'ieee-p1363' };\n            break;\n        }\n        default:\n            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);\n    }\n    if (isJWK) {\n        return { format: 'jwk', key, ...options };\n    }\n    return options ? { ...options, key } : key;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACA,MAAM,gBAAgB,IAAI,IAAI;IAC1B;QAAC;QAAS;KAAQ;IAClB;QAAC;QAAU;KAAY;IACvB;QAAC;QAAS;KAAQ;IAClB;QAAC;QAAS;KAAQ;CACrB;AACc,SAAS,aAAa,GAAG,EAAE,GAAG;IACzC,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI,eAAe,kIAAS,EAAE;QAC1B,oBAAoB,IAAI,iBAAiB;QACzC,uBAAuB,IAAI,oBAAoB;IACnD,OACK;QACD,QAAQ;QACR,OAAQ,IAAI,GAAG;YACX,KAAK;gBACD,oBAAoB;gBACpB;YACJ,KAAK;gBACD,oBAAoB;gBACpB;YACJ,KAAK;gBAAO;oBACR,IAAI,IAAI,GAAG,KAAK,WAAW;wBACvB,oBAAoB;wBACpB;oBACJ;oBACA,IAAI,IAAI,GAAG,KAAK,SAAS;wBACrB,oBAAoB;wBACpB;oBACJ;oBACA,MAAM,IAAI,UAAU;gBACxB;YACA;gBACI,MAAM,IAAI,UAAU;QAC5B;IACJ;IACA,IAAI;IACJ,OAAQ;QACJ,KAAK;YACD,IAAI,sBAAsB,WAAW;gBACjC,MAAM,IAAI,UAAU,CAAC,qEAAqE,CAAC;YAC/F;YACA;QACJ,KAAK;YACD,IAAI,CAAC;gBAAC;gBAAW;aAAQ,CAAC,QAAQ,CAAC,oBAAoB;gBACnD,MAAM,IAAI,UAAU;YACxB;YACA;QACJ,KAAK;QACL,KAAK;QACL,KAAK;YACD,IAAI,sBAAsB,OAAO;gBAC7B,MAAM,IAAI,UAAU;YACxB;YACA,IAAA,uLAAc,EAAC,KAAK;YACpB;QACJ,KAAK;QACL,KAAK;QACL,KAAK;YACD,IAAI,sBAAsB,WAAW;gBACjC,MAAM,EAAE,aAAa,EAAE,iBAAiB,EAAE,UAAU,EAAE,GAAG;gBACzD,MAAM,SAAS,SAAS,IAAI,KAAK,CAAC,CAAC,IAAI;gBACvC,IAAI,kBAAkB,aAClB,CAAC,kBAAkB,CAAC,GAAG,EAAE,QAAQ,IAAI,sBAAsB,aAAa,GAAG;oBAC3E,MAAM,IAAI,UAAU,CAAC,6FAA6F,EAAE,KAAK;gBAC7H;gBACA,IAAI,eAAe,aAAa,aAAa,UAAU,GAAG;oBACtD,MAAM,IAAI,UAAU,CAAC,yGAAyG,EAAE,KAAK;gBACzI;YACJ,OACK,IAAI,sBAAsB,OAAO;gBAClC,MAAM,IAAI,UAAU;YACxB;YACA,IAAA,uLAAc,EAAC,KAAK;YACpB,UAAU;gBACN,SAAS,kIAAS,CAAC,qBAAqB;gBACxC,YAAY,kIAAS,CAAC,sBAAsB;YAChD;YACA;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YAAS;gBACV,IAAI,sBAAsB,MAAM;oBAC5B,MAAM,IAAI,UAAU;gBACxB;gBACA,MAAM,SAAS,IAAA,sLAAa,EAAC;gBAC7B,MAAM,WAAW,cAAc,GAAG,CAAC;gBACnC,IAAI,WAAW,UAAU;oBACrB,MAAM,IAAI,UAAU,CAAC,uDAAuD,EAAE,SAAS,MAAM,EAAE,QAAQ;gBAC3G;gBACA,UAAU;oBAAE,aAAa;gBAAa;gBACtC;YACJ;QACA;YACI,MAAM,IAAI,mLAAgB,CAAC,CAAC,IAAI,EAAE,IAAI,2DAA2D,CAAC;IAC1G;IACA,IAAI,OAAO;QACP,OAAO;YAAE,QAAQ;YAAO;YAAK,GAAG,OAAO;QAAC;IAC5C;IACA,OAAO,UAAU;QAAE,GAAG,OAAO;QAAE;IAAI,IAAI;AAC3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 706, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/crypto_key.js"],"sourcesContent":["function unusable(name, prop = 'algorithm.name') {\n    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);\n}\nfunction isAlgorithm(algorithm, name) {\n    return algorithm.name === name;\n}\nfunction getHashLength(hash) {\n    return parseInt(hash.name.slice(4), 10);\n}\nfunction getNamedCurve(alg) {\n    switch (alg) {\n        case 'ES256':\n            return 'P-256';\n        case 'ES384':\n            return 'P-384';\n        case 'ES512':\n            return 'P-521';\n        default:\n            throw new Error('unreachable');\n    }\n}\nfunction checkUsage(key, usages) {\n    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {\n        let msg = 'CryptoKey does not support this operation, its usages must include ';\n        if (usages.length > 2) {\n            const last = usages.pop();\n            msg += `one of ${usages.join(', ')}, or ${last}.`;\n        }\n        else if (usages.length === 2) {\n            msg += `one of ${usages[0]} or ${usages[1]}.`;\n        }\n        else {\n            msg += `${usages[0]}.`;\n        }\n        throw new TypeError(msg);\n    }\n}\nexport function checkSigCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'HS256':\n        case 'HS384':\n        case 'HS512': {\n            if (!isAlgorithm(key.algorithm, 'HMAC'))\n                throw unusable('HMAC');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'RS256':\n        case 'RS384':\n        case 'RS512': {\n            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))\n                throw unusable('RSASSA-PKCS1-v1_5');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'PS256':\n        case 'PS384':\n        case 'PS512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))\n                throw unusable('RSA-PSS');\n            const expected = parseInt(alg.slice(2), 10);\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        case 'EdDSA': {\n            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {\n                throw unusable('Ed25519 or Ed448');\n            }\n            break;\n        }\n        case 'Ed25519': {\n            if (!isAlgorithm(key.algorithm, 'Ed25519'))\n                throw unusable('Ed25519');\n            break;\n        }\n        case 'ES256':\n        case 'ES384':\n        case 'ES512': {\n            if (!isAlgorithm(key.algorithm, 'ECDSA'))\n                throw unusable('ECDSA');\n            const expected = getNamedCurve(alg);\n            const actual = key.algorithm.namedCurve;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.namedCurve');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\nexport function checkEncCryptoKey(key, alg, ...usages) {\n    switch (alg) {\n        case 'A128GCM':\n        case 'A192GCM':\n        case 'A256GCM': {\n            if (!isAlgorithm(key.algorithm, 'AES-GCM'))\n                throw unusable('AES-GCM');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'A128KW':\n        case 'A192KW':\n        case 'A256KW': {\n            if (!isAlgorithm(key.algorithm, 'AES-KW'))\n                throw unusable('AES-KW');\n            const expected = parseInt(alg.slice(1, 4), 10);\n            const actual = key.algorithm.length;\n            if (actual !== expected)\n                throw unusable(expected, 'algorithm.length');\n            break;\n        }\n        case 'ECDH': {\n            switch (key.algorithm.name) {\n                case 'ECDH':\n                case 'X25519':\n                case 'X448':\n                    break;\n                default:\n                    throw unusable('ECDH, X25519, or X448');\n            }\n            break;\n        }\n        case 'PBES2-HS256+A128KW':\n        case 'PBES2-HS384+A192KW':\n        case 'PBES2-HS512+A256KW':\n            if (!isAlgorithm(key.algorithm, 'PBKDF2'))\n                throw unusable('PBKDF2');\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512': {\n            if (!isAlgorithm(key.algorithm, 'RSA-OAEP'))\n                throw unusable('RSA-OAEP');\n            const expected = parseInt(alg.slice(9), 10) || 1;\n            const actual = getHashLength(key.algorithm.hash);\n            if (actual !== expected)\n                throw unusable(`SHA-${expected}`, 'algorithm.hash');\n            break;\n        }\n        default:\n            throw new TypeError('CryptoKey does not support this operation');\n    }\n    checkUsage(key, usages);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/get_sign_verify_key.js"],"sourcesContent":["import { KeyObject, createSecretKey } from 'node:crypto';\nimport { isCryptoKey } from './webcrypto.js';\nimport { checkSigCryptoKey } from '../lib/crypto_key.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nimport * as jwk from '../lib/is_jwk.js';\nexport default function getSignVerifyKey(alg, key, usage) {\n    if (key instanceof Uint8Array) {\n        if (!alg.startsWith('HS')) {\n            throw new TypeError(invalidKeyInput(key, ...types));\n        }\n        return createSecretKey(key);\n    }\n    if (key instanceof KeyObject) {\n        return key;\n    }\n    if (isCryptoKey(key)) {\n        checkSigCryptoKey(key, alg, usage);\n        return KeyObject.from(key);\n    }\n    if (jwk.isJWK(key)) {\n        if (alg.startsWith('HS')) {\n            return createSecretKey(Buffer.from(key.k, 'base64url'));\n        }\n        return key;\n    }\n    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array', 'JSON Web Key'));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACe,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACpD,IAAI,eAAe,YAAY;QAC3B,IAAI,CAAC,IAAI,UAAU,CAAC,OAAO;YACvB,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,QAAQ,gLAAK;QACrD;QACA,OAAO,IAAA,wIAAe,EAAC;IAC3B;IACA,IAAI,eAAe,kIAAS,EAAE;QAC1B,OAAO;IACX;IACA,IAAI,IAAA,oLAAW,EAAC,MAAM;QAClB,IAAA,uLAAiB,EAAC,KAAK,KAAK;QAC5B,OAAO,kIAAS,CAAC,IAAI,CAAC;IAC1B;IACA,IAAI,uKAAS,CAAC,MAAM;QAChB,IAAI,IAAI,UAAU,CAAC,OAAO;YACtB,OAAO,IAAA,wIAAe,EAAC,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE;QAC9C;QACA,OAAO;IACX;IACA,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,QAAQ,gLAAK,EAAE,cAAc;AACrE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 907, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/sign.js"],"sourcesContent":["import * as crypto from 'node:crypto';\nimport { promisify } from 'node:util';\nimport nodeDigest from './dsa_digest.js';\nimport hmacDigest from './hmac_digest.js';\nimport nodeKey from './node_key.js';\nimport getSignKey from './get_sign_verify_key.js';\nconst oneShotSign = promisify(crypto.sign);\nconst sign = async (alg, key, data) => {\n    const k = getSignKey(alg, key, 'sign');\n    if (alg.startsWith('HS')) {\n        const hmac = crypto.createHmac(hmacDigest(alg), k);\n        hmac.update(data);\n        return hmac.digest();\n    }\n    return oneShotSign(nodeDigest(alg), data, nodeKey(alg, k));\n};\nexport default sign;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,MAAM,cAAc,IAAA,8HAAS,EAAC,6HAAW;AACzC,MAAM,OAAO,OAAO,KAAK,KAAK;IAC1B,MAAM,IAAI,IAAA,0LAAU,EAAC,KAAK,KAAK;IAC/B,IAAI,IAAI,UAAU,CAAC,OAAO;QACtB,MAAM,OAAO,mIAAiB,CAAC,IAAA,kLAAU,EAAC,MAAM;QAChD,KAAK,MAAM,CAAC;QACZ,OAAO,KAAK,MAAM;IACtB;IACA,OAAO,YAAY,IAAA,iLAAU,EAAC,MAAM,MAAM,IAAA,+KAAO,EAAC,KAAK;AAC3D;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 938, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/is_disjoint.js"],"sourcesContent":["const isDisjoint = (...headers) => {\n    const sources = headers.filter(Boolean);\n    if (sources.length === 0 || sources.length === 1) {\n        return true;\n    }\n    let acc;\n    for (const header of sources) {\n        const parameters = Object.keys(header);\n        if (!acc || acc.size === 0) {\n            acc = new Set(parameters);\n            continue;\n        }\n        for (const parameter of parameters) {\n            if (acc.has(parameter)) {\n                return false;\n            }\n            acc.add(parameter);\n        }\n    }\n    return true;\n};\nexport default isDisjoint;\n"],"names":[],"mappings":";;;;AAAA,MAAM,aAAa,CAAC,GAAG;IACnB,MAAM,UAAU,QAAQ,MAAM,CAAC;IAC/B,IAAI,QAAQ,MAAM,KAAK,KAAK,QAAQ,MAAM,KAAK,GAAG;QAC9C,OAAO;IACX;IACA,IAAI;IACJ,KAAK,MAAM,UAAU,QAAS;QAC1B,MAAM,aAAa,OAAO,IAAI,CAAC;QAC/B,IAAI,CAAC,OAAO,IAAI,IAAI,KAAK,GAAG;YACxB,MAAM,IAAI,IAAI;YACd;QACJ;QACA,KAAK,MAAM,aAAa,WAAY;YAChC,IAAI,IAAI,GAAG,CAAC,YAAY;gBACpB,OAAO;YACX;YACA,IAAI,GAAG,CAAC;QACZ;IACJ;IACA,OAAO;AACX;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 968, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/check_key_type.js"],"sourcesContent":["import { withAlg as invalidKeyInput } from './invalid_key_input.js';\nimport isKeyLike, { types } from '../runtime/is_key_like.js';\nimport * as jwk from './is_jwk.js';\nconst tag = (key) => key?.[Symbol.toStringTag];\nconst jwkMatchesOp = (alg, key, usage) => {\n    if (key.use !== undefined && key.use !== 'sig') {\n        throw new TypeError('Invalid key for this operation, when present its use must be sig');\n    }\n    if (key.key_ops !== undefined && key.key_ops.includes?.(usage) !== true) {\n        throw new TypeError(`Invalid key for this operation, when present its key_ops must include ${usage}`);\n    }\n    if (key.alg !== undefined && key.alg !== alg) {\n        throw new TypeError(`Invalid key for this operation, when present its alg must be ${alg}`);\n    }\n    return true;\n};\nconst symmetricTypeCheck = (alg, key, usage, allowJwk) => {\n    if (key instanceof Uint8Array)\n        return;\n    if (allowJwk && jwk.isJWK(key)) {\n        if (jwk.isSecretJWK(key) && jwkMatchesOp(alg, key, usage))\n            return;\n        throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK \"kty\" (Key Type) equal to \"oct\" and the JWK \"k\" (Key Value) present`);\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, 'Uint8Array', allowJwk ? 'JSON Web Key' : null));\n    }\n    if (key.type !== 'secret') {\n        throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type \"secret\"`);\n    }\n};\nconst asymmetricTypeCheck = (alg, key, usage, allowJwk) => {\n    if (allowJwk && jwk.isJWK(key)) {\n        switch (usage) {\n            case 'sign':\n                if (jwk.isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a private JWK`);\n            case 'verify':\n                if (jwk.isPublicJWK(key) && jwkMatchesOp(alg, key, usage))\n                    return;\n                throw new TypeError(`JSON Web Key for this operation be a public JWK`);\n        }\n    }\n    if (!isKeyLike(key)) {\n        throw new TypeError(invalidKeyInput(alg, key, ...types, allowJwk ? 'JSON Web Key' : null));\n    }\n    if (key.type === 'secret') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type \"secret\"`);\n    }\n    if (usage === 'sign' && key.type === 'public') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type \"private\"`);\n    }\n    if (usage === 'decrypt' && key.type === 'public') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type \"private\"`);\n    }\n    if (key.algorithm && usage === 'verify' && key.type === 'private') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type \"public\"`);\n    }\n    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {\n        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type \"public\"`);\n    }\n};\nfunction checkKeyType(allowJwk, alg, key, usage) {\n    const symmetric = alg.startsWith('HS') ||\n        alg === 'dir' ||\n        alg.startsWith('PBES2') ||\n        /^A\\d{3}(?:GCM)?KW$/.test(alg);\n    if (symmetric) {\n        symmetricTypeCheck(alg, key, usage, allowJwk);\n    }\n    else {\n        asymmetricTypeCheck(alg, key, usage, allowJwk);\n    }\n}\nexport default checkKeyType.bind(undefined, false);\nexport const checkKeyTypeWithJwk = checkKeyType.bind(undefined, true);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AACA,MAAM,MAAM,CAAC,MAAQ,KAAK,CAAC,OAAO,WAAW,CAAC;AAC9C,MAAM,eAAe,CAAC,KAAK,KAAK;IAC5B,IAAI,IAAI,GAAG,KAAK,aAAa,IAAI,GAAG,KAAK,OAAO;QAC5C,MAAM,IAAI,UAAU;IACxB;IACA,IAAI,IAAI,OAAO,KAAK,aAAa,IAAI,OAAO,CAAC,QAAQ,GAAG,WAAW,MAAM;QACrE,MAAM,IAAI,UAAU,CAAC,sEAAsE,EAAE,OAAO;IACxG;IACA,IAAI,IAAI,GAAG,KAAK,aAAa,IAAI,GAAG,KAAK,KAAK;QAC1C,MAAM,IAAI,UAAU,CAAC,6DAA6D,EAAE,KAAK;IAC7F;IACA,OAAO;AACX;AACA,MAAM,qBAAqB,CAAC,KAAK,KAAK,OAAO;IACzC,IAAI,eAAe,YACf;IACJ,IAAI,YAAY,uKAAS,CAAC,MAAM;QAC5B,IAAI,6KAAe,CAAC,QAAQ,aAAa,KAAK,KAAK,QAC/C;QACJ,MAAM,IAAI,UAAU,CAAC,uHAAuH,CAAC;IACjJ;IACA,IAAI,CAAC,IAAA,kLAAS,EAAC,MAAM;QACjB,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,KAAK,QAAQ,gLAAK,EAAE,cAAc,WAAW,iBAAiB;IACtG;IACA,IAAI,IAAI,IAAI,KAAK,UAAU;QACvB,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,4DAA4D,CAAC;IACjG;AACJ;AACA,MAAM,sBAAsB,CAAC,KAAK,KAAK,OAAO;IAC1C,IAAI,YAAY,uKAAS,CAAC,MAAM;QAC5B,OAAQ;YACJ,KAAK;gBACD,IAAI,8KAAgB,CAAC,QAAQ,aAAa,KAAK,KAAK,QAChD;gBACJ,MAAM,IAAI,UAAU,CAAC,gDAAgD,CAAC;YAC1E,KAAK;gBACD,IAAI,6KAAe,CAAC,QAAQ,aAAa,KAAK,KAAK,QAC/C;gBACJ,MAAM,IAAI,UAAU,CAAC,+CAA+C,CAAC;QAC7E;IACJ;IACA,IAAI,CAAC,IAAA,kLAAS,EAAC,MAAM;QACjB,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,KAAK,QAAQ,gLAAK,EAAE,WAAW,iBAAiB;IACxF;IACA,IAAI,IAAI,IAAI,KAAK,UAAU;QACvB,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,iEAAiE,CAAC;IACtG;IACA,IAAI,UAAU,UAAU,IAAI,IAAI,KAAK,UAAU;QAC3C,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,qEAAqE,CAAC;IAC1G;IACA,IAAI,UAAU,aAAa,IAAI,IAAI,KAAK,UAAU;QAC9C,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,wEAAwE,CAAC;IAC7G;IACA,IAAI,IAAI,SAAS,IAAI,UAAU,YAAY,IAAI,IAAI,KAAK,WAAW;QAC/D,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,sEAAsE,CAAC;IAC3G;IACA,IAAI,IAAI,SAAS,IAAI,UAAU,aAAa,IAAI,IAAI,KAAK,WAAW;QAChE,MAAM,IAAI,UAAU,GAAG,IAAI,KAAK,uEAAuE,CAAC;IAC5G;AACJ;AACA,SAAS,aAAa,QAAQ,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK;IAC3C,MAAM,YAAY,IAAI,UAAU,CAAC,SAC7B,QAAQ,SACR,IAAI,UAAU,CAAC,YACf,qBAAqB,IAAI,CAAC;IAC9B,IAAI,WAAW;QACX,mBAAmB,KAAK,KAAK,OAAO;IACxC,OACK;QACD,oBAAoB,KAAK,KAAK,OAAO;IACzC;AACJ;uCACe,aAAa,IAAI,CAAC,WAAW;AACrC,MAAM,sBAAsB,aAAa,IAAI,CAAC,WAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/validate_crit.js"],"sourcesContent":["import { JOSENotSupported } from '../util/errors.js';\nfunction validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {\n    if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be integrity protected');\n    }\n    if (!protectedHeader || protectedHeader.crit === undefined) {\n        return new Set();\n    }\n    if (!Array.isArray(protectedHeader.crit) ||\n        protectedHeader.crit.length === 0 ||\n        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {\n        throw new Err('\"crit\" (Critical) Header Parameter MUST be an array of non-empty strings when present');\n    }\n    let recognized;\n    if (recognizedOption !== undefined) {\n        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);\n    }\n    else {\n        recognized = recognizedDefault;\n    }\n    for (const parameter of protectedHeader.crit) {\n        if (!recognized.has(parameter)) {\n            throw new JOSENotSupported(`Extension Header Parameter \"${parameter}\" is not recognized`);\n        }\n        if (joseHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" is missing`);\n        }\n        if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {\n            throw new Err(`Extension Header Parameter \"${parameter}\" MUST be integrity protected`);\n        }\n    }\n    return new Set(protectedHeader.crit);\n}\nexport default validateCrit;\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,aAAa,GAAG,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,eAAe,EAAE,UAAU;IACvF,IAAI,WAAW,IAAI,KAAK,aAAa,iBAAiB,SAAS,WAAW;QACtE,MAAM,IAAI,IAAI;IAClB;IACA,IAAI,CAAC,mBAAmB,gBAAgB,IAAI,KAAK,WAAW;QACxD,OAAO,IAAI;IACf;IACA,IAAI,CAAC,MAAM,OAAO,CAAC,gBAAgB,IAAI,KACnC,gBAAgB,IAAI,CAAC,MAAM,KAAK,KAChC,gBAAgB,IAAI,CAAC,IAAI,CAAC,CAAC,QAAU,OAAO,UAAU,YAAY,MAAM,MAAM,KAAK,IAAI;QACvF,MAAM,IAAI,IAAI;IAClB;IACA,IAAI;IACJ,IAAI,qBAAqB,WAAW;QAChC,aAAa,IAAI,IAAI;eAAI,OAAO,OAAO,CAAC;eAAsB,kBAAkB,OAAO;SAAG;IAC9F,OACK;QACD,aAAa;IACjB;IACA,KAAK,MAAM,aAAa,gBAAgB,IAAI,CAAE;QAC1C,IAAI,CAAC,WAAW,GAAG,CAAC,YAAY;YAC5B,MAAM,IAAI,mLAAgB,CAAC,CAAC,4BAA4B,EAAE,UAAU,mBAAmB,CAAC;QAC5F;QACA,IAAI,UAAU,CAAC,UAAU,KAAK,WAAW;YACrC,MAAM,IAAI,IAAI,CAAC,4BAA4B,EAAE,UAAU,YAAY,CAAC;QACxE;QACA,IAAI,WAAW,GAAG,CAAC,cAAc,eAAe,CAAC,UAAU,KAAK,WAAW;YACvE,MAAM,IAAI,IAAI,CAAC,4BAA4B,EAAE,UAAU,6BAA6B,CAAC;QACzF;IACJ;IACA,OAAO,IAAI,IAAI,gBAAgB,IAAI;AACvC;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1093, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jws/flattened/sign.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport { checkKeyTypeWithJwk } from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    _payload;\n    _protectedHeader;\n    _unprotectedHeader;\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyTypeWithJwk(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACO,MAAM;IACT,SAAS;IACT,iBAAiB;IACjB,mBAAmB;IACnB,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,CAAC,mBAAmB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,mBAAmB,eAAe,EAAE;QAChC,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACvB,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,gBAAgB,GAAG;QACxB,OAAO,IAAI;IACf;IACA,qBAAqB,iBAAiB,EAAE;QACpC,IAAI,IAAI,CAAC,kBAAkB,EAAE;YACzB,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,CAAC,kBAAkB,GAAG;QAC1B,OAAO,IAAI;IACf;IACA,MAAM,KAAK,GAAG,EAAE,OAAO,EAAE;QACrB,IAAI,CAAC,IAAI,CAAC,gBAAgB,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE;YACpD,MAAM,IAAI,6KAAU,CAAC;QACzB;QACA,IAAI,CAAC,IAAA,8KAAU,EAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,kBAAkB,GAAG;YAC7D,MAAM,IAAI,6KAAU,CAAC;QACzB;QACA,MAAM,aAAa;YACf,GAAG,IAAI,CAAC,gBAAgB;YACxB,GAAG,IAAI,CAAC,kBAAkB;QAC9B;QACA,MAAM,aAAa,IAAA,gLAAY,EAAC,6KAAU,EAAE,IAAI,IAAI;YAAC;gBAAC;gBAAO;aAAK;SAAC,GAAG,SAAS,MAAM,IAAI,CAAC,gBAAgB,EAAE;QAC5G,IAAI,MAAM;QACV,IAAI,WAAW,GAAG,CAAC,QAAQ;YACvB,MAAM,IAAI,CAAC,gBAAgB,CAAC,GAAG;YAC/B,IAAI,OAAO,QAAQ,WAAW;gBAC1B,MAAM,IAAI,6KAAU,CAAC;YACzB;QACJ;QACA,MAAM,EAAE,GAAG,EAAE,GAAG;QAChB,IAAI,OAAO,QAAQ,YAAY,CAAC,KAAK;YACjC,MAAM,IAAI,6KAAU,CAAC;QACzB;QACA,IAAA,6LAAmB,EAAC,KAAK,KAAK;QAC9B,IAAI,UAAU,IAAI,CAAC,QAAQ;QAC3B,IAAI,KAAK;YACL,UAAU,+KAAO,CAAC,MAAM,CAAC,IAAA,+KAAS,EAAC;QACvC;QACA,IAAI;QACJ,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACvB,kBAAkB,+KAAO,CAAC,MAAM,CAAC,IAAA,+KAAS,EAAC,KAAK,SAAS,CAAC,IAAI,CAAC,gBAAgB;QACnF,OACK;YACD,kBAAkB,+KAAO,CAAC,MAAM,CAAC;QACrC;QACA,MAAM,OAAO,IAAA,8KAAM,EAAC,iBAAiB,+KAAO,CAAC,MAAM,CAAC,MAAM;QAC1D,MAAM,YAAY,MAAM,IAAA,2KAAI,EAAC,KAAK,KAAK;QACvC,MAAM,MAAM;YACR,WAAW,IAAA,+KAAS,EAAC;YACrB,SAAS;QACb;QACA,IAAI,KAAK;YACL,IAAI,OAAO,GAAG,+KAAO,CAAC,MAAM,CAAC;QACjC;QACA,IAAI,IAAI,CAAC,kBAAkB,EAAE;YACzB,IAAI,MAAM,GAAG,IAAI,CAAC,kBAAkB;QACxC;QACA,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACvB,IAAI,SAAS,GAAG,+KAAO,CAAC,MAAM,CAAC;QACnC;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1196, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jws/compact/sign.js"],"sourcesContent":["import { FlattenedSign } from '../flattened/sign.js';\nexport class CompactSign {\n    _flattened;\n    constructor(payload) {\n        this._flattened = new FlattenedSign(payload);\n    }\n    setProtectedHeader(protectedHeader) {\n        this._flattened.setProtectedHeader(protectedHeader);\n        return this;\n    }\n    async sign(key, options) {\n        const jws = await this._flattened.sign(key, options);\n        if (jws.payload === undefined) {\n            throw new TypeError('use the flattened module for creating JWS with b64: false');\n        }\n        return `${jws.protected}.${jws.payload}.${jws.signature}`;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM;IACT,WAAW;IACX,YAAY,OAAO,CAAE;QACjB,IAAI,CAAC,UAAU,GAAG,IAAI,0LAAa,CAAC;IACxC;IACA,mBAAmB,eAAe,EAAE;QAChC,IAAI,CAAC,UAAU,CAAC,kBAAkB,CAAC;QACnC,OAAO,IAAI;IACf;IACA,MAAM,KAAK,GAAG,EAAE,OAAO,EAAE;QACrB,MAAM,MAAM,MAAM,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;QAC5C,IAAI,IAAI,OAAO,KAAK,WAAW;YAC3B,MAAM,IAAI,UAAU;QACxB;QACA,OAAO,GAAG,IAAI,SAAS,CAAC,CAAC,EAAE,IAAI,OAAO,CAAC,CAAC,EAAE,IAAI,SAAS,EAAE;IAC7D;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1223, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/epoch.js"],"sourcesContent":["export default (date) => Math.floor(date.getTime() / 1000);\n"],"names":[],"mappings":";;;;uCAAe,CAAC,OAAS,KAAK,KAAK,CAAC,KAAK,OAAO,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1232, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/secs.js"],"sourcesContent":["const minute = 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\nconst year = day * 365.25;\nconst REGEX = /^(\\+|\\-)? ?(\\d+|\\d+\\.\\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;\nexport default (str) => {\n    const matched = REGEX.exec(str);\n    if (!matched || (matched[4] && matched[1])) {\n        throw new TypeError('Invalid time period format');\n    }\n    const value = parseFloat(matched[2]);\n    const unit = matched[3].toLowerCase();\n    let numericDate;\n    switch (unit) {\n        case 'sec':\n        case 'secs':\n        case 'second':\n        case 'seconds':\n        case 's':\n            numericDate = Math.round(value);\n            break;\n        case 'minute':\n        case 'minutes':\n        case 'min':\n        case 'mins':\n        case 'm':\n            numericDate = Math.round(value * minute);\n            break;\n        case 'hour':\n        case 'hours':\n        case 'hr':\n        case 'hrs':\n        case 'h':\n            numericDate = Math.round(value * hour);\n            break;\n        case 'day':\n        case 'days':\n        case 'd':\n            numericDate = Math.round(value * day);\n            break;\n        case 'week':\n        case 'weeks':\n        case 'w':\n            numericDate = Math.round(value * week);\n            break;\n        default:\n            numericDate = Math.round(value * year);\n            break;\n    }\n    if (matched[1] === '-' || matched[4] === 'ago') {\n        return -numericDate;\n    }\n    return numericDate;\n};\n"],"names":[],"mappings":";;;;AAAA,MAAM,SAAS;AACf,MAAM,OAAO,SAAS;AACtB,MAAM,MAAM,OAAO;AACnB,MAAM,OAAO,MAAM;AACnB,MAAM,OAAO,MAAM;AACnB,MAAM,QAAQ;uCACC,CAAC;IACZ,MAAM,UAAU,MAAM,IAAI,CAAC;IAC3B,IAAI,CAAC,WAAY,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,EAAE,EAAG;QACxC,MAAM,IAAI,UAAU;IACxB;IACA,MAAM,QAAQ,WAAW,OAAO,CAAC,EAAE;IACnC,MAAM,OAAO,OAAO,CAAC,EAAE,CAAC,WAAW;IACnC,IAAI;IACJ,OAAQ;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,cAAc,KAAK,KAAK,CAAC;YACzB;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,cAAc,KAAK,KAAK,CAAC,QAAQ;YACjC;QACJ,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACD,cAAc,KAAK,KAAK,CAAC,QAAQ;YACjC;QACJ,KAAK;QACL,KAAK;QACL,KAAK;YACD,cAAc,KAAK,KAAK,CAAC,QAAQ;YACjC;QACJ,KAAK;QACL,KAAK;QACL,KAAK;YACD,cAAc,KAAK,KAAK,CAAC,QAAQ;YACjC;QACJ;YACI,cAAc,KAAK,KAAK,CAAC,QAAQ;YACjC;IACR;IACA,IAAI,OAAO,CAAC,EAAE,KAAK,OAAO,OAAO,CAAC,EAAE,KAAK,OAAO;QAC5C,OAAO,CAAC;IACZ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1295, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jwt/produce.js"],"sourcesContent":["import epoch from '../lib/epoch.js';\nimport isObject from '../lib/is_object.js';\nimport secs from '../lib/secs.js';\nfunction validateInput(label, input) {\n    if (!Number.isFinite(input)) {\n        throw new TypeError(`Invalid ${label} input`);\n    }\n    return input;\n}\nexport class ProduceJWT {\n    _payload;\n    constructor(payload = {}) {\n        if (!isObject(payload)) {\n            throw new TypeError('JWT Claims Set MUST be an object');\n        }\n        this._payload = payload;\n    }\n    setIssuer(issuer) {\n        this._payload = { ...this._payload, iss: issuer };\n        return this;\n    }\n    setSubject(subject) {\n        this._payload = { ...this._payload, sub: subject };\n        return this;\n    }\n    setAudience(audience) {\n        this._payload = { ...this._payload, aud: audience };\n        return this;\n    }\n    setJti(jwtId) {\n        this._payload = { ...this._payload, jti: jwtId };\n        return this;\n    }\n    setNotBefore(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, nbf: validateInput('setNotBefore', epoch(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, nbf: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setExpirationTime(input) {\n        if (typeof input === 'number') {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', input) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, exp: validateInput('setExpirationTime', epoch(input)) };\n        }\n        else {\n            this._payload = { ...this._payload, exp: epoch(new Date()) + secs(input) };\n        }\n        return this;\n    }\n    setIssuedAt(input) {\n        if (typeof input === 'undefined') {\n            this._payload = { ...this._payload, iat: epoch(new Date()) };\n        }\n        else if (input instanceof Date) {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', epoch(input)) };\n        }\n        else if (typeof input === 'string') {\n            this._payload = {\n                ...this._payload,\n                iat: validateInput('setIssuedAt', epoch(new Date()) + secs(input)),\n            };\n        }\n        else {\n            this._payload = { ...this._payload, iat: validateInput('setIssuedAt', input) };\n        }\n        return this;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1414, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jwt/sign.js"],"sourcesContent":["import { CompactSign } from '../jws/compact/sign.js';\nimport { JWTInvalid } from '../util/errors.js';\nimport { encoder } from '../lib/buffer_utils.js';\nimport { ProduceJWT } from './produce.js';\nexport class SignJWT extends ProduceJWT {\n    _protectedHeader;\n    setProtectedHeader(protectedHeader) {\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));\n        sig.setProtectedHeader(this._protectedHeader);\n        if (Array.isArray(this._protectedHeader?.crit) &&\n            this._protectedHeader.crit.includes('b64') &&\n            this._protectedHeader.b64 === false) {\n            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n        }\n        return sig.sign(key, options);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AACO,MAAM,gBAAgB,6KAAU;IACnC,iBAAiB;IACjB,mBAAmB,eAAe,EAAE;QAChC,IAAI,CAAC,gBAAgB,GAAG;QACxB,OAAO,IAAI;IACf;IACA,MAAM,KAAK,GAAG,EAAE,OAAO,EAAE;QACrB,MAAM,MAAM,IAAI,sLAAW,CAAC,+KAAO,CAAC,MAAM,CAAC,KAAK,SAAS,CAAC,IAAI,CAAC,QAAQ;QACvE,IAAI,kBAAkB,CAAC,IAAI,CAAC,gBAAgB;QAC5C,IAAI,MAAM,OAAO,CAAC,IAAI,CAAC,gBAAgB,EAAE,SACrC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,UACpC,IAAI,CAAC,gBAAgB,CAAC,GAAG,KAAK,OAAO;YACrC,MAAM,IAAI,6KAAU,CAAC;QACzB;QACA,OAAO,IAAI,IAAI,CAAC,KAAK;IACzB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/verify.js"],"sourcesContent":["import * as crypto from 'node:crypto';\nimport { promisify } from 'node:util';\nimport nodeDigest from './dsa_digest.js';\nimport nodeKey from './node_key.js';\nimport sign from './sign.js';\nimport getVerifyKey from './get_sign_verify_key.js';\nconst oneShotVerify = promisify(crypto.verify);\nconst verify = async (alg, key, signature, data) => {\n    const k = getVerifyKey(alg, key, 'verify');\n    if (alg.startsWith('HS')) {\n        const expected = await sign(alg, k, data);\n        const actual = signature;\n        try {\n            return crypto.timingSafeEqual(actual, expected);\n        }\n        catch {\n            return false;\n        }\n    }\n    const algorithm = nodeDigest(alg);\n    const keyInput = nodeKey(alg, k);\n    try {\n        return await oneShotVerify(algorithm, data, keyInput, signature);\n    }\n    catch {\n        return false;\n    }\n};\nexport default verify;\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,MAAM,gBAAgB,IAAA,8HAAS,EAAC,+HAAa;AAC7C,MAAM,SAAS,OAAO,KAAK,KAAK,WAAW;IACvC,MAAM,IAAI,IAAA,0LAAY,EAAC,KAAK,KAAK;IACjC,IAAI,IAAI,UAAU,CAAC,OAAO;QACtB,MAAM,WAAW,MAAM,IAAA,2KAAI,EAAC,KAAK,GAAG;QACpC,MAAM,SAAS;QACf,IAAI;YACA,OAAO,wIAAsB,CAAC,QAAQ;QAC1C,EACA,OAAM;YACF,OAAO;QACX;IACJ;IACA,MAAM,YAAY,IAAA,iLAAU,EAAC;IAC7B,MAAM,WAAW,IAAA,+KAAO,EAAC,KAAK;IAC9B,IAAI;QACA,OAAO,MAAM,cAAc,WAAW,MAAM,UAAU;IAC1D,EACA,OAAM;QACF,OAAO;IACX;AACJ;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1486, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/validate_algorithms.js"],"sourcesContent":["const validateAlgorithms = (option, algorithms) => {\n    if (algorithms !== undefined &&\n        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {\n        throw new TypeError(`\"${option}\" option must be an array of strings`);\n    }\n    if (!algorithms) {\n        return undefined;\n    }\n    return new Set(algorithms);\n};\nexport default validateAlgorithms;\n"],"names":[],"mappings":";;;;AAAA,MAAM,qBAAqB,CAAC,QAAQ;IAChC,IAAI,eAAe,aACf,CAAC,CAAC,MAAM,OAAO,CAAC,eAAe,WAAW,IAAI,CAAC,CAAC,IAAM,OAAO,MAAM,SAAS,GAAG;QAC/E,MAAM,IAAI,UAAU,CAAC,CAAC,EAAE,OAAO,oCAAoC,CAAC;IACxE;IACA,IAAI,CAAC,YAAY;QACb,OAAO;IACX;IACA,OAAO,IAAI,IAAI;AACnB;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1504, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/asn1.js"],"sourcesContent":["import { createPrivateKey, createPublicKey, KeyObject } from 'node:crypto';\nimport { Buffer } from 'node:buffer';\nimport { isCryptoKey } from './webcrypto.js';\nimport isKeyObject from './is_key_object.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { types } from './is_key_like.js';\nconst genericExport = (keyType, keyFormat, key) => {\n    let keyObject;\n    if (isCryptoKey(key)) {\n        if (!key.extractable) {\n            throw new TypeError('CryptoKey is not extractable');\n        }\n        keyObject = KeyObject.from(key);\n    }\n    else if (isKeyObject(key)) {\n        keyObject = key;\n    }\n    else {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (keyObject.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return keyObject.export({ format: 'pem', type: keyFormat });\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nexport const fromPKCS8 = (pem) => createPrivateKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, ''), 'base64'),\n    type: 'pkcs8',\n    format: 'der',\n});\nexport const fromSPKI = (pem) => createPublicKey({\n    key: Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, ''), 'base64'),\n    type: 'spki',\n    format: 'der',\n});\nexport const fromX509 = (pem) => createPublicKey({\n    key: pem,\n    type: 'spki',\n    format: 'pem',\n});\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA,MAAM,gBAAgB,CAAC,SAAS,WAAW;IACvC,IAAI;IACJ,IAAI,IAAA,oLAAW,EAAC,MAAM;QAClB,IAAI,CAAC,IAAI,WAAW,EAAE;YAClB,MAAM,IAAI,UAAU;QACxB;QACA,YAAY,kIAAS,CAAC,IAAI,CAAC;IAC/B,OACK,IAAI,IAAA,oLAAW,EAAC,MAAM;QACvB,YAAY;IAChB,OACK;QACD,MAAM,IAAI,UAAU,IAAA,oLAAe,EAAC,QAAQ,gLAAK;IACrD;IACA,IAAI,UAAU,IAAI,KAAK,SAAS;QAC5B,MAAM,IAAI,UAAU,CAAC,aAAa,EAAE,QAAQ,IAAI,CAAC;IACrD;IACA,OAAO,UAAU,MAAM,CAAC;QAAE,QAAQ;QAAO,MAAM;IAAU;AAC7D;AACO,MAAM,SAAS,CAAC;IACnB,OAAO,cAAc,UAAU,QAAQ;AAC3C;AACO,MAAM,UAAU,CAAC;IACpB,OAAO,cAAc,WAAW,SAAS;AAC7C;AACO,MAAM,YAAY,CAAC,MAAQ,IAAA,yIAAgB,EAAC;QAC/C,KAAK,+HAAM,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,+CAA+C,KAAK;QACjF,MAAM;QACN,QAAQ;IACZ;AACO,MAAM,WAAW,CAAC,MAAQ,IAAA,wIAAe,EAAC;QAC7C,KAAK,+HAAM,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,8CAA8C,KAAK;QAChF,MAAM;QACN,QAAQ;IACZ;AACO,MAAM,WAAW,CAAC,MAAQ,IAAA,wIAAe,EAAC;QAC7C,KAAK;QACL,MAAM;QACN,QAAQ;IACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1573, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/runtime/jwk_to_key.js"],"sourcesContent":["import { createPrivateKey, createPublicKey } from 'node:crypto';\nconst parse = (key) => {\n    if (key.d) {\n        return createPrivateKey({ format: 'jwk', key });\n    }\n    return createPublicKey({ format: 'jwk', key });\n};\nexport default parse;\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,QAAQ,CAAC;IACX,IAAI,IAAI,CAAC,EAAE;QACP,OAAO,IAAA,yIAAgB,EAAC;YAAE,QAAQ;YAAO;QAAI;IACjD;IACA,OAAO,IAAA,wIAAe,EAAC;QAAE,QAAQ;QAAO;IAAI;AAChD;uCACe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1596, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/key/import.js"],"sourcesContent":["import { decode as decodeBase64URL } from '../runtime/base64url.js';\nimport { fromSPKI, fromPKCS8, fromX509 } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport isObject from '../lib/is_object.js';\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return fromSPKI(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    return fromX509(x509, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return fromPKCS8(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg) {\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg ||= jwk.alg;\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if ('oth' in jwk && jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,eAAe,WAAW,IAAI,EAAE,GAAG,EAAE,OAAO;IAC/C,IAAI,OAAO,SAAS,YAAY,KAAK,OAAO,CAAC,kCAAkC,GAAG;QAC9E,MAAM,IAAI,UAAU;IACxB;IACA,OAAO,IAAA,4KAAQ,EAAC,MAAM,KAAK;AAC/B;AACO,eAAe,WAAW,IAAI,EAAE,GAAG,EAAE,OAAO;IAC/C,IAAI,OAAO,SAAS,YAAY,KAAK,OAAO,CAAC,mCAAmC,GAAG;QAC/E,MAAM,IAAI,UAAU;IACxB;IACA,OAAO,IAAA,4KAAQ,EAAC,MAAM,KAAK;AAC/B;AACO,eAAe,YAAY,KAAK,EAAE,GAAG,EAAE,OAAO;IACjD,IAAI,OAAO,UAAU,YAAY,MAAM,OAAO,CAAC,mCAAmC,GAAG;QACjF,MAAM,IAAI,UAAU;IACxB;IACA,OAAO,IAAA,6KAAS,EAAC,OAAO,KAAK;AACjC;AACO,eAAe,UAAU,GAAG,EAAE,GAAG;IACpC,IAAI,CAAC,IAAA,4KAAQ,EAAC,MAAM;QAChB,MAAM,IAAI,UAAU;IACxB;IACA,QAAQ,IAAI,GAAG;IACf,OAAQ,IAAI,GAAG;QACX,KAAK;YACD,IAAI,OAAO,IAAI,CAAC,KAAK,YAAY,CAAC,IAAI,CAAC,EAAE;gBACrC,MAAM,IAAI,UAAU;YACxB;YACA,OAAO,IAAA,+KAAe,EAAC,IAAI,CAAC;QAChC,KAAK;YACD,IAAI,SAAS,OAAO,IAAI,GAAG,KAAK,WAAW;gBACvC,MAAM,IAAI,mLAAgB,CAAC;YAC/B;QACJ,KAAK;QACL,KAAK;YACD,OAAO,IAAA,iLAAW,EAAC;gBAAE,GAAG,GAAG;gBAAE;YAAI;QACrC;YACI,MAAM,IAAI,mLAAgB,CAAC;IACnC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1663, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jws/flattened/verify.js"],"sourcesContent":["import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport { checkKeyTypeWithJwk } from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nimport { isJWK } from '../../lib/is_jwk.js';\nimport { importJWK } from '../../key/import.js';\nexport async function flattenedVerify(jws, key, options) {\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter value not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n        checkKeyTypeWithJwk(alg, key, 'verify');\n        if (isJWK(key)) {\n            key = await importJWK(key, alg);\n        }\n    }\n    else {\n        checkKeyTypeWithJwk(alg, key, 'verify');\n    }\n    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    let signature;\n    try {\n        signature = base64url(jws.signature);\n    }\n    catch {\n        throw new JWSInvalid('Failed to base64url decode the signature');\n    }\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        try {\n            payload = base64url(jws.payload);\n        }\n        catch {\n            throw new JWSInvalid('Failed to base64url decode the payload');\n        }\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1807, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jws/compact/verify.js"],"sourcesContent":["import { flattenedVerify } from '../flattened/verify.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { decoder } from '../../lib/buffer_utils.js';\nexport async function compactVerify(jws, key, options) {\n    if (jws instanceof Uint8Array) {\n        jws = decoder.decode(jws);\n    }\n    if (typeof jws !== 'string') {\n        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');\n    }\n    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');\n    if (length !== 3) {\n        throw new JWSInvalid('Invalid Compact JWS');\n    }\n    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);\n    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,eAAe,cAAc,GAAG,EAAE,GAAG,EAAE,OAAO;IACjD,IAAI,eAAe,YAAY;QAC3B,MAAM,+KAAO,CAAC,MAAM,CAAC;IACzB;IACA,IAAI,OAAO,QAAQ,UAAU;QACzB,MAAM,IAAI,6KAAU,CAAC;IACzB;IACA,MAAM,EAAE,GAAG,eAAe,EAAE,GAAG,OAAO,EAAE,GAAG,SAAS,EAAE,MAAM,EAAE,GAAG,IAAI,KAAK,CAAC;IAC3E,IAAI,WAAW,GAAG;QACd,MAAM,IAAI,6KAAU,CAAC;IACzB;IACA,MAAM,WAAW,MAAM,IAAA,8LAAe,EAAC;QAAE;QAAS,WAAW;QAAiB;IAAU,GAAG,KAAK;IAChG,MAAM,SAAS;QAAE,SAAS,SAAS,OAAO;QAAE,iBAAiB,SAAS,eAAe;IAAC;IACtF,IAAI,OAAO,QAAQ,YAAY;QAC3B,OAAO;YAAE,GAAG,MAAM;YAAE,KAAK,SAAS,GAAG;QAAC;IAC1C;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/lib/jwt_claims_set.js"],"sourcesContent":["import { JWTClaimValidationFailed, JWTExpired, JWTInvalid } from '../util/errors.js';\nimport { decoder } from './buffer_utils.js';\nimport epoch from './epoch.js';\nimport secs from './secs.js';\nimport isObject from './is_object.js';\nconst normalizeTyp = (value) => value.toLowerCase().replace(/^application\\//, '');\nconst checkAudiencePresence = (audPayload, audOption) => {\n    if (typeof audPayload === 'string') {\n        return audOption.includes(audPayload);\n    }\n    if (Array.isArray(audPayload)) {\n        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));\n    }\n    return false;\n};\nexport default (protectedHeader, encodedPayload, options = {}) => {\n    let payload;\n    try {\n        payload = JSON.parse(decoder.decode(encodedPayload));\n    }\n    catch {\n    }\n    if (!isObject(payload)) {\n        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');\n    }\n    const { typ } = options;\n    if (typ &&\n        (typeof protectedHeader.typ !== 'string' ||\n            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {\n        throw new JWTClaimValidationFailed('unexpected \"typ\" JWT header value', payload, 'typ', 'check_failed');\n    }\n    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;\n    const presenceCheck = [...requiredClaims];\n    if (maxTokenAge !== undefined)\n        presenceCheck.push('iat');\n    if (audience !== undefined)\n        presenceCheck.push('aud');\n    if (subject !== undefined)\n        presenceCheck.push('sub');\n    if (issuer !== undefined)\n        presenceCheck.push('iss');\n    for (const claim of new Set(presenceCheck.reverse())) {\n        if (!(claim in payload)) {\n            throw new JWTClaimValidationFailed(`missing required \"${claim}\" claim`, payload, claim, 'missing');\n        }\n    }\n    if (issuer &&\n        !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {\n        throw new JWTClaimValidationFailed('unexpected \"iss\" claim value', payload, 'iss', 'check_failed');\n    }\n    if (subject && payload.sub !== subject) {\n        throw new JWTClaimValidationFailed('unexpected \"sub\" claim value', payload, 'sub', 'check_failed');\n    }\n    if (audience &&\n        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n        throw new JWTClaimValidationFailed('unexpected \"aud\" claim value', payload, 'aud', 'check_failed');\n    }\n    let tolerance;\n    switch (typeof options.clockTolerance) {\n        case 'string':\n            tolerance = secs(options.clockTolerance);\n            break;\n        case 'number':\n            tolerance = options.clockTolerance;\n            break;\n        case 'undefined':\n            tolerance = 0;\n            break;\n        default:\n            throw new TypeError('Invalid clockTolerance option type');\n    }\n    const { currentDate } = options;\n    const now = epoch(currentDate || new Date());\n    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {\n        throw new JWTClaimValidationFailed('\"iat\" claim must be a number', payload, 'iat', 'invalid');\n    }\n    if (payload.nbf !== undefined) {\n        if (typeof payload.nbf !== 'number') {\n            throw new JWTClaimValidationFailed('\"nbf\" claim must be a number', payload, 'nbf', 'invalid');\n        }\n        if (payload.nbf > now + tolerance) {\n            throw new JWTClaimValidationFailed('\"nbf\" claim timestamp check failed', payload, 'nbf', 'check_failed');\n        }\n    }\n    if (payload.exp !== undefined) {\n        if (typeof payload.exp !== 'number') {\n            throw new JWTClaimValidationFailed('\"exp\" claim must be a number', payload, 'exp', 'invalid');\n        }\n        if (payload.exp <= now - tolerance) {\n            throw new JWTExpired('\"exp\" claim timestamp check failed', payload, 'exp', 'check_failed');\n        }\n    }\n    if (maxTokenAge) {\n        const age = now - payload.iat;\n        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);\n        if (age - tolerance > max) {\n            throw new JWTExpired('\"iat\" claim timestamp check failed (too far in the past)', payload, 'iat', 'check_failed');\n        }\n        if (age < 0 - tolerance) {\n            throw new JWTClaimValidationFailed('\"iat\" claim timestamp check failed (it should be in the past)', payload, 'iat', 'check_failed');\n        }\n    }\n    return payload;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1962, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/jose/dist/node/esm/jwt/verify.js"],"sourcesContent":["import { compactVerify } from '../jws/compact/verify.js';\nimport jwtPayload from '../lib/jwt_claims_set.js';\nimport { JWTInvalid } from '../util/errors.js';\nexport async function jwtVerify(jwt, key, options) {\n    const verified = await compactVerify(jwt, key, options);\n    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {\n        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');\n    }\n    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);\n    const result = { payload, protectedHeader: verified.protectedHeader };\n    if (typeof key === 'function') {\n        return { ...result, key: verified.key };\n    }\n    return result;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,eAAe,UAAU,GAAG,EAAE,GAAG,EAAE,OAAO;IAC7C,MAAM,WAAW,MAAM,IAAA,0LAAa,EAAC,KAAK,KAAK;IAC/C,IAAI,SAAS,eAAe,CAAC,IAAI,EAAE,SAAS,UAAU,SAAS,eAAe,CAAC,GAAG,KAAK,OAAO;QAC1F,MAAM,IAAI,6KAAU,CAAC;IACzB;IACA,MAAM,UAAU,IAAA,iLAAU,EAAC,SAAS,eAAe,EAAE,SAAS,OAAO,EAAE;IACvE,MAAM,SAAS;QAAE;QAAS,iBAAiB,SAAS,eAAe;IAAC;IACpE,IAAI,OAAO,QAAQ,YAAY;QAC3B,OAAO;YAAE,GAAG,MAAM;YAAE,KAAK,SAAS,GAAG;QAAC;IAC1C;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1994, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/grants.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { RoomConfiguration } from '@livekit/protocol';\nimport { TrackSource } from '@livekit/protocol';\nimport type { JWTPayload } from 'jose';\n\nexport function trackSourceToString(source: TrackSource) {\n  switch (source) {\n    case TrackSource.CAMERA:\n      return 'camera';\n    case TrackSource.MICROPHONE:\n      return 'microphone';\n    case TrackSource.SCREEN_SHARE:\n      return 'screen_share';\n    case TrackSource.SCREEN_SHARE_AUDIO:\n      return 'screen_share_audio';\n    default:\n      throw new TypeError(`Cannot convert TrackSource ${source} to string`);\n  }\n}\n\nexport function claimsToJwtPayload(\n  grant: ClaimGrants,\n): JWTPayload & { video?: Record<string, unknown> } {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const claim: Record<string, any> = { ...grant };\n  // eslint-disable-next-line no-restricted-syntax\n  if (Array.isArray(claim.video?.canPublishSources)) {\n    claim.video.canPublishSources = claim.video.canPublishSources.map(trackSourceToString);\n  }\n  return claim;\n}\n\nexport interface VideoGrant {\n  /** permission to create a room */\n  roomCreate?: boolean;\n\n  /** permission to join a room as a participant, room must be set */\n  roomJoin?: boolean;\n\n  /** permission to list rooms */\n  roomList?: boolean;\n\n  /** permission to start a recording */\n  roomRecord?: boolean;\n\n  /** permission to control a specific room, room must be set */\n  roomAdmin?: boolean;\n\n  /** name of the room, must be set for admin or join permissions */\n  room?: string;\n\n  /** permissions to control ingress, not specific to any room or ingress */\n  ingressAdmin?: boolean;\n\n  /**\n   * allow participant to publish. If neither canPublish or canSubscribe is set,\n   * both publish and subscribe are enabled\n   */\n  canPublish?: boolean;\n\n  /**\n   * TrackSource types that the participant is allowed to publish\n   * When set, it supersedes CanPublish. Only sources explicitly set here can be published\n   */\n  canPublishSources?: TrackSource[];\n\n  /** allow participant to subscribe to other tracks */\n  canSubscribe?: boolean;\n\n  /**\n   * allow participants to publish data, defaults to true if not set\n   */\n  canPublishData?: boolean;\n\n  /**\n   * by default, a participant is not allowed to update its own metadata\n   */\n  canUpdateOwnMetadata?: boolean;\n\n  /** participant isn't visible to others */\n  hidden?: boolean;\n\n  /** participant is recording the room, when set, allows room to indicate it's being recorded */\n  recorder?: boolean;\n\n  /** participant allowed to connect to LiveKit as Agent Framework worker */\n  agent?: boolean;\n\n  /** allow participant to subscribe to metrics */\n  canSubscribeMetrics?: boolean;\n\n  /** destination room which this participant can forward to */\n  destinationRoom?: string;\n}\n\nexport interface SIPGrant {\n  /** manage sip resources */\n  admin?: boolean;\n\n  /** make outbound calls */\n  call?: boolean;\n}\n\nexport interface InferenceGrant {\n  /** perform inference */\n  perform?: boolean;\n}\n\n/** @internal */\nexport interface ClaimGrants extends JWTPayload {\n  name?: string;\n  video?: VideoGrant;\n  sip?: SIPGrant;\n  inference?: InferenceGrant;\n  kind?: string;\n  metadata?: string;\n  attributes?: Record<string, string>;\n  sha256?: string;\n  roomPreset?: string;\n  roomConfig?: RoomConfiguration;\n}\n"],"names":[],"mappings":";;;;;;AAIA,SAAS,mBAAmB;;AAGrB,SAAS,oBAAoB,MAAA,EAAqB;IACvD,OAAQ,QAAQ;QACd,KAAK,wLAAA,CAAY,MAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,UAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,YAAA;YACf,OAAO;QACT,KAAK,wLAAA,CAAY,kBAAA;YACf,OAAO;QACT;YACE,MAAM,IAAI,UAAU,CAAA,2BAAA,EAA8B,MAAM,CAAA,UAAA,CAAY;IACxE;AACF;AAEO,SAAS,mBACd,KAAA,EACkD;IAxBpD,IAAA;IA0BE,MAAM,QAA6B;QAAE,GAAG,KAAA;IAAM;IAE9C,IAAI,MAAM,OAAA,CAAA,CAAQ,KAAA,MAAM,KAAA,KAAN,OAAA,KAAA,IAAA,GAAa,iBAAiB,GAAG;QACjD,MAAM,KAAA,CAAM,iBAAA,GAAoB,MAAM,KAAA,CAAM,iBAAA,CAAkB,GAAA,CAAI,mBAAmB;IACvF;IACA,OAAO;AACT","debugId":null}},
    {"offset": {"line": 2032, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/AccessToken.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { RoomConfiguration } from '@livekit/protocol';\nimport * as jose from 'jose';\nimport type { ClaimGrants, InferenceGrant, SIPGrant, VideoGrant } from './grants.js';\nimport { claimsToJwtPayload } from './grants.js';\n\n// 6 hours\nconst defaultTTL = `6h`;\n\nconst defaultClockToleranceSeconds = 10;\n\nexport interface AccessTokenOptions {\n  /**\n   * amount of time before expiration\n   * expressed in seconds or a string describing a time span zeit/ms.\n   * eg: '2 days', '10h', or seconds as numeric value\n   */\n  ttl?: number | string;\n\n  /**\n   * display name for the participant, available as `Participant.name`\n   */\n  name?: string;\n\n  /**\n   * identity of the user, required for room join tokens\n   */\n  identity?: string;\n\n  /**\n   * custom participant metadata\n   */\n  metadata?: string;\n\n  /**\n   * custom participant attributes\n   */\n  attributes?: Record<string, string>;\n}\n\nexport class AccessToken {\n  private apiKey: string;\n\n  private apiSecret: string;\n\n  private grants: ClaimGrants;\n\n  identity?: string;\n\n  ttl: number | string;\n\n  /**\n   * Creates a new AccessToken\n   * @param apiKey - API Key, can be set in env LIVEKIT_API_KEY\n   * @param apiSecret - Secret, can be set in env LIVEKIT_API_SECRET\n   */\n  constructor(apiKey?: string, apiSecret?: string, options?: AccessTokenOptions) {\n    if (!apiKey) {\n      apiKey = process.env.LIVEKIT_API_KEY;\n    }\n    if (!apiSecret) {\n      apiSecret = process.env.LIVEKIT_API_SECRET;\n    }\n    if (!apiKey || !apiSecret) {\n      throw Error('api-key and api-secret must be set');\n    }\n    // @ts-expect-error we're not including dom lib for the server sdk so document is not defined\n    else if (typeof document !== 'undefined') {\n      // check against document rather than window because deno provides window\n      console.error(\n        'You should not include your API secret in your web client bundle.\\n\\n' +\n          'Your web client should request a token from your backend server which should then use ' +\n          'the API secret to generate a token. See https://docs.livekit.io/client/connect/',\n      );\n    }\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.grants = {};\n    this.identity = options?.identity;\n    this.ttl = options?.ttl || defaultTTL;\n    if (typeof this.ttl === 'number') {\n      this.ttl = `${this.ttl}s`;\n    }\n    if (options?.metadata) {\n      this.metadata = options.metadata;\n    }\n    if (options?.attributes) {\n      this.attributes = options.attributes;\n    }\n    if (options?.name) {\n      this.name = options.name;\n    }\n  }\n\n  /**\n   * Adds a video grant to this token.\n   * @param grant -\n   */\n  addGrant(grant: VideoGrant) {\n    this.grants.video = { ...(this.grants.video ?? {}), ...grant };\n  }\n\n  /**\n   * Adds an inference grant to this token.\n   * @param grant -\n   */\n  addInferenceGrant(grant: InferenceGrant) {\n    this.grants.inference = { ...(this.grants.inference ?? {}), ...grant };\n  }\n\n  /**\n   * Adds a SIP grant to this token.\n   * @param grant -\n   */\n  addSIPGrant(grant: SIPGrant) {\n    this.grants.sip = { ...(this.grants.sip ?? {}), ...grant };\n  }\n\n  get name(): string | undefined {\n    return this.grants.name;\n  }\n\n  set name(name: string) {\n    this.grants.name = name;\n  }\n\n  get metadata(): string | undefined {\n    return this.grants.metadata;\n  }\n\n  /**\n   * Set metadata to be passed to the Participant, used only when joining the room\n   */\n  set metadata(md: string) {\n    this.grants.metadata = md;\n  }\n\n  get attributes(): Record<string, string> | undefined {\n    return this.grants.attributes;\n  }\n\n  set attributes(attrs: Record<string, string>) {\n    this.grants.attributes = attrs;\n  }\n\n  get kind(): string | undefined {\n    return this.grants.kind;\n  }\n\n  set kind(kind: string) {\n    this.grants.kind = kind;\n  }\n\n  get sha256(): string | undefined {\n    return this.grants.sha256;\n  }\n\n  set sha256(sha: string | undefined) {\n    this.grants.sha256 = sha;\n  }\n\n  get roomPreset(): string | undefined {\n    return this.grants.roomPreset;\n  }\n\n  set roomPreset(preset: string | undefined) {\n    this.grants.roomPreset = preset;\n  }\n\n  get roomConfig(): RoomConfiguration | undefined {\n    return this.grants.roomConfig;\n  }\n\n  set roomConfig(config: RoomConfiguration | undefined) {\n    this.grants.roomConfig = config;\n  }\n\n  /**\n   * @returns JWT encoded token\n   */\n  async toJwt(): Promise<string> {\n    // TODO: check for video grant validity\n\n    const secret = new TextEncoder().encode(this.apiSecret);\n\n    const jwt = new jose.SignJWT(claimsToJwtPayload(this.grants))\n      .setProtectedHeader({ alg: 'HS256' })\n      .setIssuer(this.apiKey)\n      .setExpirationTime(this.ttl)\n      .setNotBefore(0);\n    if (this.identity) {\n      jwt.setSubject(this.identity);\n    } else if (this.grants.video?.roomJoin) {\n      throw Error('identity is required for join but not set');\n    }\n    return jwt.sign(secret);\n  }\n}\n\nexport class TokenVerifier {\n  private apiKey: string;\n\n  private apiSecret: string;\n\n  constructor(apiKey: string, apiSecret: string) {\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n  }\n\n  async verify(\n    token: string,\n    clockTolerance: string | number = defaultClockToleranceSeconds,\n  ): Promise<ClaimGrants> {\n    const secret = new TextEncoder().encode(this.apiSecret);\n    const { payload } = await jose.jwtVerify(token, secret, {\n      issuer: this.apiKey,\n      clockTolerance,\n    });\n    if (!payload) {\n      throw Error('invalid token');\n    }\n\n    return payload as ClaimGrants;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2190, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/ServiceBase.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { AccessToken } from './AccessToken.js';\nimport type { SIPGrant, VideoGrant } from './grants.js';\n\n/**\n * Utilities to handle authentication\n */\nexport class ServiceBase {\n  private readonly apiKey?: string;\n\n  private readonly secret?: string;\n\n  private readonly ttl: string;\n\n  /**\n   * @param apiKey - API Key.\n   * @param secret - API Secret.\n   * @param ttl - token TTL\n   */\n  constructor(apiKey?: string, secret?: string, ttl?: string) {\n    this.apiKey = apiKey;\n    this.secret = secret;\n    this.ttl = ttl || '10m';\n  }\n\n  async authHeader(grant: VideoGrant, sip?: SIPGrant): Promise<Record<string, string>> {\n    const at = new AccessToken(this.apiKey, this.secret, { ttl: this.ttl });\n    if (grant) {\n      at.addGrant(grant);\n    }\n    if (sip) {\n      at.addSIPGrant(sip);\n    }\n    return {\n      Authorization: `Bearer ${await at.toJwt()}`,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,SAAS,mBAAmB;;AAMrB,MAAM,YAAY;IAAA;;;;GAAA,GAYvB,YAAY,MAAA,EAAiB,MAAA,EAAiB,GAAA,CAAc;QAC1D,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,GAAA,GAAM,OAAO;IACpB;IAEA,MAAM,WAAW,KAAA,EAAmB,GAAA,EAAiD;QACnF,MAAM,KAAK,IAAI,gLAAA,CAAY,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAA,EAAQ;YAAE,KAAK,IAAA,CAAK,GAAA;QAAI,CAAC;QACtE,IAAI,OAAO;YACT,GAAG,QAAA,CAAS,KAAK;QACnB;QACA,IAAI,KAAK;YACP,GAAG,WAAA,CAAY,GAAG;QACpB;QACA,OAAO;YACL,eAAe,CAAA,OAAA,EAAU,MAAM,GAAG,KAAA,CAAM,CAAC,EAAA;QAC3C;IACF;AACF","debugId":null}},
    {"offset": {"line": 2227, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/TwirpRPC.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { JsonValue } from '@bufbuild/protobuf';\n\n// twirp RPC adapter for client implementation\n\nconst defaultPrefix = '/twirp';\n\nexport const livekitPackage = 'livekit';\nexport interface Rpc {\n  request(\n    service: string,\n    method: string,\n    data: JsonValue,\n    headers: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    timeout?: number,\n  ): Promise<string>;\n}\n\nexport class TwirpError extends Error {\n  status: number;\n  code?: string;\n  metadata?: Record<string, string>;\n\n  constructor(\n    name: string,\n    message: string,\n    status: number,\n    code?: string,\n    metadata?: Record<string, string>,\n  ) {\n    super(message);\n    this.name = name;\n    this.status = status;\n    this.code = code;\n    this.metadata = metadata;\n  }\n}\n\n/**\n * JSON based Twirp V7 RPC\n */\nexport class TwirpRpc {\n  host: string;\n\n  pkg: string;\n\n  prefix: string;\n\n  constructor(host: string, pkg: string, prefix?: string) {\n    if (host.startsWith('ws')) {\n      host = host.replace('ws', 'http');\n    }\n    this.host = host;\n    this.pkg = pkg;\n    this.prefix = prefix || defaultPrefix;\n  }\n\n  async request(\n    service: string,\n    method: string,\n    data: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    headers: any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    timeout = 60,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const path = `${this.prefix}/${this.pkg}.${service}/${method}`;\n    const url = new URL(path, this.host);\n    const init: RequestInit = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json;charset=UTF-8',\n        ...headers,\n      },\n      body: JSON.stringify(data),\n    };\n\n    if (timeout) {\n      init.signal = AbortSignal.timeout(timeout * 1000);\n    }\n\n    const response = await fetch(url, init);\n\n    if (!response.ok) {\n      const isJson = response.headers.get('content-type') === 'application/json';\n      let errorMessage = 'Unknown internal error';\n      let errorCode: string | undefined = undefined;\n      let metadata: Record<string, string> | undefined = undefined;\n      try {\n        if (isJson) {\n          const parsedError = (await response.json()) as Record<string, unknown>;\n          if ('msg' in parsedError) {\n            errorMessage = <string>parsedError.msg;\n          }\n          if ('code' in parsedError) {\n            errorCode = <string>parsedError.code;\n          }\n          if ('meta' in parsedError) {\n            metadata = <Record<string, string>>parsedError.meta;\n          }\n        } else {\n          errorMessage = await response.text();\n        }\n      } catch (e) {\n        // parsing went wrong, no op and we keep default error message\n        console.debug(`Error when trying to parse error message, using defaults`, e);\n      }\n\n      throw new TwirpError(response.statusText, errorMessage, response.status, errorCode, metadata);\n    }\n    const parsedResp = (await response.json()) as Record<string, unknown>;\n\n    const camelcaseKeys = await import('camelcase-keys').then((mod) => mod.default);\n    return camelcaseKeys(parsedResp, { deep: true });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAOA,MAAM,gBAAgB;AAEf,MAAM,iBAAiB;AAWvB,MAAM,mBAAmB,MAAM;IAKpC,YACE,IAAA,EACA,OAAA,EACA,MAAA,EACA,IAAA,EACA,QAAA,CACA;QACA,KAAA,CAAM,OAAO;QACb,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,MAAA,GAAS;QACd,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,QAAA,GAAW;IAClB;AACF;AAKO,MAAM,SAAS;IAOpB,YAAY,IAAA,EAAc,GAAA,EAAa,MAAA,CAAiB;QACtD,IAAI,KAAK,UAAA,CAAW,IAAI,GAAG;YACzB,OAAO,KAAK,OAAA,CAAQ,MAAM,MAAM;QAClC;QACA,IAAA,CAAK,IAAA,GAAO;QACZ,IAAA,CAAK,GAAA,GAAM;QACX,IAAA,CAAK,MAAA,GAAS,UAAU;IAC1B;IAEA,MAAM,QACJ,OAAA,EACA,MAAA,EACA,IAAA,EACA,OAAA,EACA,UAAU,EAAA,EAEI;QACd,MAAM,OAAO,GAAG,IAAA,CAAK,MAAM,CAAA,CAAA,EAAI,IAAA,CAAK,GAAG,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,EAAI,MAAM,EAAA;QAC5D,MAAM,MAAM,IAAI,IAAI,MAAM,IAAA,CAAK,IAAI;QACnC,MAAM,OAAoB;YACxB,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,GAAG,OAAA;YACL;YACA,MAAM,KAAK,SAAA,CAAU,IAAI;QAC3B;QAEA,IAAI,SAAS;YACX,KAAK,MAAA,GAAS,YAAY,OAAA,CAAQ,UAAU,GAAI;QAClD;QAEA,MAAM,WAAW,MAAM,MAAM,KAAK,IAAI;QAEtC,IAAI,CAAC,SAAS,EAAA,EAAI;YAChB,MAAM,SAAS,SAAS,OAAA,CAAQ,GAAA,CAAI,cAAc,MAAM;YACxD,IAAI,eAAe;YACnB,IAAI,YAAgC,KAAA;YACpC,IAAI,WAA+C,KAAA;YACnD,IAAI;gBACF,IAAI,QAAQ;oBACV,MAAM,cAAe,MAAM,SAAS,IAAA,CAAK;oBACzC,IAAI,SAAS,aAAa;wBACxB,eAAuB,YAAY,GAAA;oBACrC;oBACA,IAAI,UAAU,aAAa;wBACzB,YAAoB,YAAY,IAAA;oBAClC;oBACA,IAAI,UAAU,aAAa;wBACzB,WAAmC,YAAY,IAAA;oBACjD;gBACF,OAAO;oBACL,eAAe,MAAM,SAAS,IAAA,CAAK;gBACrC;YACF,EAAA,OAAS,GAAG;gBAEV,QAAQ,KAAA,CAAM,CAAA,wDAAA,CAAA,EAA4D,CAAC;YAC7E;YAEA,MAAM,IAAI,WAAW,SAAS,UAAA,EAAY,cAAc,SAAS,MAAA,EAAQ,WAAW,QAAQ;QAC9F;QACA,MAAM,aAAc,MAAM,SAAS,IAAA,CAAK;QAExC,MAAM,gBAAgB,MAAM,OAAO,gBAAgB,0FAAE,IAAA,CAAK,CAAC,MAAQ,IAAI,OAAO;QAC9E,OAAO,cAAc,YAAY;YAAE,MAAM;QAAK,CAAC;IACjD;AACF","debugId":null}},
    {"offset": {"line": 2308, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/AgentDispatchClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  AgentDispatch,\n  CreateAgentDispatchRequest,\n  DeleteAgentDispatchRequest,\n  ListAgentDispatchRequest,\n  ListAgentDispatchResponse,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport { type Rpc, TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\ninterface CreateDispatchOptions {\n  // any custom data to send along with the job.\n  // note: this is different from room and participant metadata\n  metadata?: string;\n}\n\nconst svc = 'AgentDispatchService';\n\n/**\n * Client to access Agent APIs\n */\nexport class AgentDispatchClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * Create an explicit dispatch for an agent to join a room. To use explicit\n   * dispatch, your agent must be registered with an `agentName`.\n   * @param roomName - name of the room to dispatch to\n   * @param agentName - name of the agent to dispatch\n   * @param options - optional metadata to send along with the dispatch\n   * @returns the dispatch that was created\n   */\n  async createDispatch(\n    roomName: string,\n    agentName: string,\n    options?: CreateDispatchOptions,\n  ): Promise<AgentDispatch> {\n    const req = new CreateAgentDispatchRequest({\n      room: roomName,\n      agentName,\n      metadata: options?.metadata,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'CreateDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    return AgentDispatch.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Delete an explicit dispatch for an agent in a room.\n   * @param dispatchId - id of the dispatch to delete\n   * @param roomName - name of the room the dispatch is for\n   */\n  async deleteDispatch(dispatchId: string, roomName: string): Promise<void> {\n    const req = new DeleteAgentDispatchRequest({\n      dispatchId,\n      room: roomName,\n    }).toJson();\n    await this.rpc.request(\n      svc,\n      'DeleteDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n  }\n\n  /**\n   * Get an Agent dispatch by ID\n   * @param dispatchId - id of the dispatch to get\n   * @param roomName - name of the room the dispatch is for\n   * @returns the dispatch that was found, or undefined if not found\n   */\n  async getDispatch(dispatchId: string, roomName: string): Promise<AgentDispatch | undefined> {\n    const req = new ListAgentDispatchRequest({\n      dispatchId,\n      room: roomName,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });\n    if (res.agentDispatches.length === 0) {\n      return undefined;\n    }\n    return res.agentDispatches[0];\n  }\n\n  /**\n   * List all agent dispatches for a room\n   * @param roomName - name of the room to list dispatches for\n   * @returns the list of dispatches\n   */\n  async listDispatch(roomName: string): Promise<AgentDispatch[]> {\n    const req = new ListAgentDispatchRequest({\n      room: roomName,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListDispatch',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }),\n    );\n    const res = ListAgentDispatchResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.agentDispatches;\n  }\n}\n"],"names":[],"mappings":";;;;AAGA;AAOA,SAAS,mBAAmB;AAC5B,SAAmB,UAAU,sBAAsB;;;;AAQnD,MAAM,MAAM;AAKL,MAAM,4BAA4B,gLAAA,CAAY;IAAA;;;;GAAA,GAQnD,YAAY,IAAA,EAAc,MAAA,EAAiB,MAAA,CAAiB;QAC1D,KAAA,CAAM,QAAQ,MAAM;QACpB,IAAA,CAAK,GAAA,GAAM,IAAI,0KAAA,CAAS,MAAM,gLAAc;IAC9C;IAAA;;;;;;;GAAA,GAUA,MAAM,eACJ,QAAA,EACA,SAAA,EACA,OAAA,EACwB;QACxB,MAAM,MAAM,IAAI,uMAAA,CAA2B;YACzC,MAAM;YACN;YACA,UAAU,WAAA,OAAA,KAAA,IAAA,QAAS,QAAA;QACrB,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,kBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,OAAO,0LAAA,CAAc,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACnE;IAAA;;;;GAAA,GAOA,MAAM,eAAe,UAAA,EAAoB,QAAA,EAAiC;QACxE,MAAM,MAAM,IAAI,uMAAA,CAA2B;YACzC;YACA,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CACb,KACA,kBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;IAE7D;IAAA;;;;;GAAA,GAQA,MAAM,YAAY,UAAA,EAAoB,QAAA,EAAsD;QAC1F,MAAM,MAAM,IAAI,qMAAA,CAAyB;YACvC;YACA,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,gBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,MAAM,MAAM,sMAAA,CAA0B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;QAClF,IAAI,IAAI,eAAA,CAAgB,MAAA,KAAW,GAAG;YACpC,OAAO,KAAA;QACT;QACA,OAAO,IAAI,eAAA,CAAgB,CAAC,CAAA;IAC9B;IAAA;;;;GAAA,GAOA,MAAM,aAAa,QAAA,EAA4C;QAC7D,MAAM,MAAM,IAAI,qMAAA,CAAyB;YACvC,MAAM;QACR,CAAC,EAAE,MAAA,CAAO;QACV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,gBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,CAAC;QAE3D,MAAM,MAAM,sMAAA,CAA0B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;QAClF,OAAO,IAAI,eAAA;IACb;AACF","debugId":null}},
    {"offset": {"line": 2409, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/EgressClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type {\n  DirectFileOutput,\n  EncodedFileOutput,\n  EncodingOptions,\n  EncodingOptionsPreset,\n  ImageOutput,\n  SegmentedFileOutput,\n  StreamOutput,\n  WebhookConfig,\n} from '@livekit/protocol';\nimport {\n  AudioMixing,\n  EgressInfo,\n  ListEgressRequest,\n  ListEgressResponse,\n  ParticipantEgressRequest,\n  RoomCompositeEgressRequest,\n  StopEgressRequest,\n  TrackCompositeEgressRequest,\n  TrackEgressRequest,\n  UpdateLayoutRequest,\n  UpdateStreamRequest,\n  WebEgressRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'Egress';\n\nexport interface BaseOptions {\n  /**\n   * webhooks to call for this request, optional.\n   */\n  webhooks?: WebhookConfig[];\n}\n\nexport interface RoomCompositeOptions extends BaseOptions {\n  /**\n   * egress layout. optional\n   */\n  layout?: string;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n  /**\n   * record audio only. optional\n   */\n  audioOnly?: boolean;\n  /**\n   * record video only. optional\n   */\n  videoOnly?: boolean;\n  /**\n   * custom template url. optional\n   */\n  customBaseUrl?: string;\n  /**\n   * audio mixing options. optional\n   */\n  audioMixing?: AudioMixing;\n}\n\nexport interface WebOptions extends BaseOptions {\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n  /**\n   * record audio only. optional\n   */\n  audioOnly?: boolean;\n  /**\n   * record video only. optional\n   */\n  videoOnly?: boolean;\n  /**\n   * await START_RECORDING chrome log\n   */\n  awaitStartSignal?: boolean;\n}\n\nexport interface ParticipantEgressOptions extends BaseOptions {\n  /**\n   * true to capture source screenshare and screenshare_audio\n   * false to capture camera and microphone\n   */\n  screenShare?: boolean;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n}\n\nexport interface TrackCompositeOptions extends BaseOptions {\n  /**\n   * audio track ID\n   */\n  audioTrackId?: string;\n  /**\n   * video track ID\n   */\n  videoTrackId?: string;\n  /**\n   * encoding options or preset. optional\n   */\n  encodingOptions?: EncodingOptionsPreset | EncodingOptions;\n}\n\n/**\n * Used to supply multiple outputs with an egress request\n */\nexport interface EncodedOutputs {\n  file?: EncodedFileOutput | undefined;\n  stream?: StreamOutput | undefined;\n  segments?: SegmentedFileOutput | undefined;\n  images?: ImageOutput | undefined;\n}\n\nexport interface ListEgressOptions {\n  roomName?: string;\n  egressId?: string;\n  active?: boolean;\n}\n\n/**\n * Client to access Egress APIs\n */\nexport class EgressClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or stream output\n   * @param opts - RoomCompositeOptions\n   */\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: RoomCompositeOptions,\n  ): Promise<EgressInfo>;\n  /**\n   * @deprecated use RoomCompositeOptions instead\n   */\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    layout?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n    audioOnly?: boolean,\n    videoOnly?: boolean,\n    customBaseUrl?: string,\n    audioMixing?: AudioMixing,\n  ): Promise<EgressInfo>;\n  async startRoomCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    optsOrLayout?: RoomCompositeOptions | string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n    audioOnly?: boolean,\n    videoOnly?: boolean,\n    customBaseUrl?: string,\n    audioMixing?: AudioMixing,\n  ): Promise<EgressInfo> {\n    let layout: string | undefined;\n    let webhooks: WebhookConfig[] | undefined;\n    if (optsOrLayout !== undefined) {\n      if (typeof optsOrLayout === 'string') {\n        layout = optsOrLayout;\n      } else {\n        const opts = <RoomCompositeOptions>optsOrLayout;\n        layout = opts.layout;\n        options = opts.encodingOptions;\n        audioOnly = opts.audioOnly;\n        videoOnly = opts.videoOnly;\n        customBaseUrl = opts.customBaseUrl;\n        audioMixing = opts.audioMixing;\n        webhooks = opts.webhooks;\n      }\n    }\n\n    layout ??= '';\n    audioOnly ??= false;\n    videoOnly ??= false;\n    customBaseUrl ??= '';\n    audioMixing ??= AudioMixing.DEFAULT_MIXING;\n\n    const {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, options);\n\n    const req = new RoomCompositeEgressRequest({\n      roomName,\n      layout,\n      audioOnly,\n      audioMixing,\n      videoOnly,\n      customBaseUrl,\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartRoomCompositeEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param url - url\n   * @param output - file or stream output\n   * @param opts - WebOptions\n   */\n  async startWebEgress(\n    url: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: WebOptions,\n  ): Promise<EgressInfo> {\n    const audioOnly = opts?.audioOnly || false;\n    const videoOnly = opts?.videoOnly || false;\n    const awaitStartSignal = opts?.awaitStartSignal || false;\n    const webhooks = opts?.webhooks || [];\n    const {\n      output: legacyOutput,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, opts?.encodingOptions);\n\n    const req = new WebEgressRequest({\n      url,\n      audioOnly,\n      videoOnly,\n      awaitStartSignal,\n      output: legacyOutput,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartWebEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Export a participant's audio and video tracks,\n   *\n   * @param roomName - room name\n   * @param output - one or more outputs\n   * @param opts - ParticipantEgressOptions\n   */\n  async startParticipantEgress(\n    roomName: string,\n    identity: string,\n    output: EncodedOutputs,\n    opts?: ParticipantEgressOptions,\n  ): Promise<EgressInfo> {\n    const webhooks = opts?.webhooks || [];\n    const { options, fileOutputs, streamOutputs, segmentOutputs, imageOutputs } =\n      this.getOutputParams(output, opts?.encodingOptions);\n    const req = new ParticipantEgressRequest({\n      roomName,\n      identity,\n      screenShare: opts?.screenShare ?? false,\n      options,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartParticipantEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or stream output\n   * @param opts - TrackCompositeOptions\n   */\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: TrackCompositeOptions,\n  ): Promise<EgressInfo>;\n  /**\n   * @deprecated use TrackCompositeOptions instead\n   */\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    audioTrackId?: string,\n    videoTrackId?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n  ): Promise<EgressInfo>;\n  async startTrackCompositeEgress(\n    roomName: string,\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    optsOrAudioTrackId?: TrackCompositeOptions | string,\n    videoTrackId?: string,\n    options?: EncodingOptionsPreset | EncodingOptions,\n  ): Promise<EgressInfo> {\n    let audioTrackId: string | undefined;\n    let webhooks: WebhookConfig[] | undefined;\n    if (optsOrAudioTrackId !== undefined) {\n      if (typeof optsOrAudioTrackId === 'string') {\n        audioTrackId = optsOrAudioTrackId;\n      } else {\n        const opts = <TrackCompositeOptions>optsOrAudioTrackId;\n        audioTrackId = opts.audioTrackId;\n        videoTrackId = opts.videoTrackId;\n        options = opts.encodingOptions;\n        webhooks = opts.webhooks;\n      }\n    }\n\n    audioTrackId ??= '';\n    videoTrackId ??= '';\n\n    const {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    } = this.getOutputParams(output, options);\n    const req = new TrackCompositeEgressRequest({\n      roomName,\n      audioTrackId,\n      videoTrackId,\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartTrackCompositeEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isEncodedOutputs(output: any): output is EncodedOutputs {\n    return (\n      (<EncodedOutputs>output).file !== undefined ||\n      (<EncodedOutputs>output).stream !== undefined ||\n      (<EncodedOutputs>output).segments !== undefined ||\n      (<EncodedOutputs>output).images !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isEncodedFileOutput(output: any): output is EncodedFileOutput {\n    return (\n      (<EncodedFileOutput>output).filepath !== undefined ||\n      (<EncodedFileOutput>output).fileType !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isSegmentedFileOutput(output: any): output is SegmentedFileOutput {\n    return (\n      (<SegmentedFileOutput>output).filenamePrefix !== undefined ||\n      (<SegmentedFileOutput>output).playlistName !== undefined ||\n      (<SegmentedFileOutput>output).filenameSuffix !== undefined\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private isStreamOutput(output: any): output is StreamOutput {\n    return (\n      (<StreamOutput>output).protocol !== undefined || (<StreamOutput>output).urls !== undefined\n    );\n  }\n\n  private getOutputParams(\n    output: EncodedOutputs | EncodedFileOutput | StreamOutput | SegmentedFileOutput,\n    opts?: EncodingOptionsPreset | EncodingOptions,\n  ) {\n    let file: EncodedFileOutput | undefined;\n    let fileOutputs: Array<EncodedFileOutput> | undefined;\n    let stream: StreamOutput | undefined;\n    let streamOutputs: Array<StreamOutput> | undefined;\n    let segments: SegmentedFileOutput | undefined;\n    let segmentOutputs: Array<SegmentedFileOutput> | undefined;\n    let imageOutputs: Array<ImageOutput> | undefined;\n\n    if (this.isEncodedOutputs(output)) {\n      if (output.file !== undefined) {\n        fileOutputs = [output.file];\n      }\n      if (output.stream !== undefined) {\n        streamOutputs = [output.stream];\n      }\n      if (output.segments !== undefined) {\n        segmentOutputs = [output.segments];\n      }\n      if (output.images !== undefined) {\n        imageOutputs = [output.images];\n      }\n    } else if (this.isEncodedFileOutput(output)) {\n      file = output;\n      fileOutputs = [file];\n    } else if (this.isSegmentedFileOutput(output)) {\n      segments = output;\n      segmentOutputs = [segments];\n    } else if (this.isStreamOutput(output)) {\n      stream = output;\n      streamOutputs = [stream];\n    }\n\n    let legacyOutput:\n      | {\n          value: EncodedFileOutput;\n          case: 'file';\n        }\n      | {\n          value: StreamOutput;\n          case: 'stream';\n        }\n      | {\n          value: SegmentedFileOutput;\n          case: 'segments';\n        }\n      | undefined;\n\n    if (file) {\n      legacyOutput = {\n        case: 'file',\n        value: file,\n      };\n    } else if (stream) {\n      legacyOutput = {\n        case: 'stream',\n        value: stream,\n      };\n    } else if (segments) {\n      legacyOutput = {\n        case: 'segments',\n        value: segments,\n      };\n    }\n    let egressOptions:\n      | {\n          value: EncodingOptionsPreset;\n          case: 'preset';\n        }\n      | {\n          value: EncodingOptions;\n          case: 'advanced';\n        }\n      | undefined;\n    if (opts) {\n      if (typeof opts === 'number') {\n        egressOptions = {\n          case: 'preset',\n          value: opts,\n        };\n      } else {\n        egressOptions = {\n          case: 'advanced',\n          value: <EncodingOptions>opts,\n        };\n      }\n    }\n\n    return {\n      output: legacyOutput,\n      options: egressOptions,\n      fileOutputs,\n      streamOutputs,\n      segmentOutputs,\n      imageOutputs,\n    };\n  }\n\n  /**\n   * @param roomName - room name\n   * @param output - file or websocket output\n   * @param trackId - track Id\n   */\n  async startTrackEgress(\n    roomName: string,\n    output: DirectFileOutput | string,\n    trackId: string,\n    webhooks?: WebhookConfig[],\n  ): Promise<EgressInfo> {\n    let legacyOutput:\n      | {\n          value: DirectFileOutput;\n          case: 'file';\n        }\n      | {\n          value: string;\n          case: 'websocketUrl';\n        }\n      | undefined;\n\n    if (typeof output === 'string') {\n      legacyOutput = {\n        case: 'websocketUrl',\n        value: output,\n      };\n    } else {\n      legacyOutput = {\n        case: 'file',\n        value: output,\n      };\n    }\n\n    const req = new TrackEgressRequest({\n      roomName,\n      trackId,\n      output: legacyOutput,\n      webhooks,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'StartTrackEgress',\n      req,\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param egressId -\n   * @param layout -\n   */\n  async updateLayout(egressId: string, layout: string): Promise<EgressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'UpdateLayout',\n      new UpdateLayoutRequest({ egressId, layout }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param egressId -\n   * @param addOutputUrls -\n   * @param removeOutputUrls -\n   */\n  async updateStream(\n    egressId: string,\n    addOutputUrls?: string[],\n    removeOutputUrls?: string[],\n  ): Promise<EgressInfo> {\n    addOutputUrls ??= [];\n    removeOutputUrls ??= [];\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateStream',\n      new UpdateStreamRequest({ egressId, addOutputUrls, removeOutputUrls }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param options - options to filter listed Egresses, by default returns all\n   * Egress instances\n   */\n  async listEgress(options?: ListEgressOptions): Promise<Array<EgressInfo>>;\n  /**\n   * @deprecated use `listEgress(options?: ListEgressOptions)` instead\n   * @param roomName - list egress for one room only\n   */\n  async listEgress(roomName?: string): Promise<Array<EgressInfo>>;\n  /**\n   * @param roomName - list egress for one room only\n   */\n  async listEgress(options?: string | ListEgressOptions): Promise<Array<EgressInfo>> {\n    let req: Partial<ListEgressRequest> = {};\n    if (typeof options === 'string') {\n      req.roomName = options;\n    } else if (options !== undefined) {\n      req = options;\n    }\n\n    const data = await this.rpc.request(\n      svc,\n      'ListEgress',\n      new ListEgressRequest(req).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return ListEgressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * @param egressId -\n   */\n  async stopEgress(egressId: string): Promise<EgressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'StopEgress',\n      new StopEgressRequest({ egressId }).toJson(),\n      await this.authHeader({ roomRecord: true }),\n    );\n    return EgressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2765, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/IngressClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { IngressAudioOptions, IngressInput, IngressVideoOptions } from '@livekit/protocol';\nimport {\n  CreateIngressRequest,\n  DeleteIngressRequest,\n  IngressInfo,\n  ListIngressRequest,\n  ListIngressResponse,\n  UpdateIngressRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'Ingress';\n\nexport interface CreateIngressOptions {\n  /**\n   * ingress name. optional\n   */\n  name?: string;\n  /**\n   * name of the room to send media to. required\n   */\n  roomName?: string;\n  /**\n   * unique identity of the participant. required\n   */\n  participantIdentity: string;\n  /**\n   * participant display name\n   */\n  participantName?: string;\n  /**\n   * metadata to attach to the participant\n   */\n  participantMetadata?: string;\n  /**\n   * @deprecated use `enableTranscoding` instead.\n   * whether to skip transcoding and forward the input media directly. Only supported by WHIP\n   */\n  bypassTranscoding?: boolean;\n  /**\n   * whether to enable transcoding or forward the input media directly.\n   * Transcoding is required for all input types except WHIP. For WHIP, the default is to not transcode.\n   */\n  enableTranscoding?: boolean | undefined;\n  /**\n   * url of the media to pull for ingresses of type URL\n   */\n  url?: string;\n  /**\n   * custom audio encoding parameters. optional\n   */\n  audio?: IngressAudioOptions;\n  /**\n   * custom video encoding parameters. optional\n   */\n  video?: IngressVideoOptions;\n}\n\nexport interface UpdateIngressOptions {\n  /**\n   * ingress name. optional\n   */\n  name: string;\n  /**\n   * name of the room to send media to.\n   */\n  roomName?: string;\n  /**\n   * unique identity of the participant.\n   */\n  participantIdentity?: string;\n  /**\n   * participant display name\n   */\n  participantName?: string;\n  /**\n   * metadata to attach to the participant\n   */\n  participantMetadata?: string;\n  /**\n   * @deprecated use `enableTranscoding` instead\n   * whether to skip transcoding and forward the input media directly. Only supported by WHIP\n   */\n  bypassTranscoding?: boolean | undefined;\n  /**\n   * whether to enable transcoding or forward the input media directly.\n   * Transcoding is required for all input types except WHIP. For WHIP, the default is to not transcode.\n   */\n  enableTranscoding?: boolean | undefined;\n  /**\n   * custom audio encoding parameters. optional\n   */\n  audio?: IngressAudioOptions;\n  /**\n   * custom video encoding parameters. optional\n   */\n  video?: IngressVideoOptions;\n}\n\nexport interface ListIngressOptions {\n  /**\n   * list ingress for one room only\n   */\n  roomName?: string;\n\n  /**\n   * list ingress by ID\n   */\n  ingressId?: string;\n}\n\n/**\n * Client to access Ingress APIs\n */\nexport class IngressClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param inputType - protocol for the ingress\n   * @param opts - CreateIngressOptions\n   */\n  async createIngress(inputType: IngressInput, opts: CreateIngressOptions): Promise<IngressInfo> {\n    let name: string = '';\n    let participantName: string = '';\n    let participantIdentity: string = '';\n    let bypassTranscoding: boolean = false;\n    let url: string = '';\n\n    if (opts == null) {\n      throw new Error('options dictionary is required');\n    }\n\n    const roomName: string | undefined = opts.roomName;\n    const enableTranscoding: boolean | undefined = opts.enableTranscoding;\n    const audio: IngressAudioOptions | undefined = opts.audio;\n    const video: IngressVideoOptions | undefined = opts.video;\n    const participantMetadata: string | undefined = opts.participantMetadata;\n\n    name = opts.name || '';\n    participantName = opts.participantName || '';\n    participantIdentity = opts.participantIdentity || '';\n    bypassTranscoding = opts.bypassTranscoding || false;\n    url = opts.url || '';\n\n    if (typeof roomName == 'undefined') {\n      throw new Error('required roomName option not provided');\n    }\n\n    if (participantIdentity == '') {\n      throw new Error('required participantIdentity option not provided');\n    }\n\n    const req = new CreateIngressRequest({\n      inputType,\n      name,\n      roomName,\n      participantIdentity,\n      participantMetadata,\n      participantName,\n      bypassTranscoding,\n      enableTranscoding,\n      url,\n      audio,\n      video,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateIngress',\n      req,\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @param ingressId - ID of the ingress to update\n   * @param opts - UpdateIngressOptions\n   */\n  async updateIngress(ingressId: string, opts: UpdateIngressOptions): Promise<IngressInfo> {\n    const name: string = opts.name || '';\n    const roomName: string = opts.roomName || '';\n    const participantName: string = opts.participantName || '';\n    const participantIdentity: string = opts.participantIdentity || '';\n    const { participantMetadata } = opts;\n    const { audio, video, bypassTranscoding, enableTranscoding } = opts;\n\n    const req = new UpdateIngressRequest({\n      ingressId,\n      name,\n      roomName,\n      participantIdentity,\n      participantName,\n      participantMetadata,\n      bypassTranscoding,\n      enableTranscoding,\n      audio,\n      video,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateIngress',\n      req,\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @deprecated use `listIngress(opts)` or `listIngress(arg)` instead\n   * @param roomName - list ingress for one room only\n   */\n  async listIngress(roomName?: string): Promise<Array<IngressInfo>>;\n  /**\n   * @param opts - list options\n   */\n  async listIngress(opts?: ListIngressOptions): Promise<Array<IngressInfo>>;\n  /**\n   * @param arg - list room name or options\n   */\n  async listIngress(arg?: string | ListIngressOptions): Promise<Array<IngressInfo>> {\n    let req: Partial<ListIngressRequest> = {};\n    if (typeof arg === 'string') {\n      req.roomName = arg;\n    } else if (arg) {\n      req = arg;\n    }\n    const data = await this.rpc.request(\n      svc,\n      'ListIngress',\n      new ListIngressRequest(req).toJson(),\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return ListIngressResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * @param ingressId - ingress to delete\n   */\n  async deleteIngress(ingressId: string): Promise<IngressInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteIngress',\n      new DeleteIngressRequest({ ingressId }).toJson(),\n      await this.authHeader({ ingressAdmin: true }),\n    );\n    return IngressInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2897, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/crypto/uuid.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n// Use the Web Crypto API if available, otherwise fallback to Node.js crypto\nexport async function getRandomBytes(size: number = 16): Promise<Uint8Array> {\n  if (globalThis.crypto) {\n    return crypto.getRandomValues(new Uint8Array(size));\n  } else {\n    const nodeCrypto = await import('node:crypto');\n    return nodeCrypto.getRandomValues(new Uint8Array(size));\n  }\n}\n"],"names":[],"mappings":";;;;AAKA,eAAsB,eAAe,OAAe,EAAA,EAAyB;IAC3E,IAAI,WAAW,MAAA,EAAQ;QACrB,OAAO,OAAO,eAAA,CAAgB,IAAI,WAAW,IAAI,CAAC;IACpD,OAAO;QACL,MAAM,aAAa,MAAM,OAAO,aAAa;QAC7C,OAAO,WAAW,eAAA,CAAgB,IAAI,WAAW,IAAI,CAAC;IACxD;AACF","debugId":null}},
    {"offset": {"line": 2915, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/RoomServiceClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { DataPacket_Kind, RoomEgress, TrackInfo } from '@livekit/protocol';\nimport {\n  CreateRoomRequest,\n  DeleteRoomRequest,\n  ForwardParticipantRequest,\n  ListParticipantsRequest,\n  ListParticipantsResponse,\n  ListRoomsRequest,\n  ListRoomsResponse,\n  MoveParticipantRequest,\n  MuteRoomTrackRequest,\n  MuteRoomTrackResponse,\n  ParticipantInfo,\n  ParticipantPermission,\n  Room,\n  RoomParticipantIdentity,\n  SendDataRequest,\n  UpdateParticipantRequest,\n  UpdateRoomMetadataRequest,\n  UpdateSubscriptionsRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\nimport { getRandomBytes } from './crypto/uuid.js';\n\n/**\n * Options for when creating a room\n */\nexport interface CreateOptions {\n  /**\n   * name of the room. required\n   */\n  name: string;\n\n  /**\n   * number of seconds to keep the room open before any participant joins\n   */\n  emptyTimeout?: number;\n\n  /**\n   * number of seconds to keep the room open after the last participant leaves\n   * this option is helpful to give a grace period for participants to re-join\n   */\n  departureTimeout?: number;\n\n  /**\n   * limit to the number of participants in a room at a time\n   */\n  maxParticipants?: number;\n\n  /**\n   * initial room metadata\n   */\n  metadata?: string;\n\n  /**\n   * add egress options\n   */\n  egress?: RoomEgress;\n\n  /**\n   * minimum playout delay in milliseconds\n   */\n  minPlayoutDelay?: number;\n\n  /**\n   * maximum playout delay in milliseconds\n   */\n  maxPlayoutDelay?: number;\n\n  /**\n   * improves A/V sync when min_playout_delay set to a value larger than 200ms.\n   * It will disables transceiver re-use -- this option is not recommended\n   * for rooms with frequent subscription changes\n   */\n  syncStreams?: boolean;\n\n  /**\n   * override the node room is allocated to, for debugging\n   * does not work with Cloud\n   */\n  nodeId?: string;\n}\n\nexport type SendDataOptions = {\n  /** If set, only deliver to listed participant identities */\n  destinationIdentities?: string[];\n  destinationSids?: string[];\n  topic?: string;\n};\n\nexport type UpdateParticipantOptions = {\n  /** only attributes you'd want to update should be set, set value to empty string to remove it */\n  attributes?: { [key: string]: string };\n  metadata?: string;\n  /** permissions are updated atomically - all desired permissions would need to be set */\n  permission?: Partial<ParticipantPermission>;\n  name?: string;\n};\n\nconst svc = 'RoomService';\n\n/**\n * Client to access Room APIs\n */\nexport class RoomServiceClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   *\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * Creates a new room. Explicit room creation is not required, since rooms will\n   * be automatically created when the first participant joins. This method can be\n   * used to customize room settings.\n   * @param options -\n   */\n  async createRoom(options: CreateOptions): Promise<Room> {\n    const data = await this.rpc.request(\n      svc,\n      'CreateRoom',\n      new CreateRoomRequest(options).toJson(),\n      await this.authHeader({ roomCreate: true }),\n    );\n    return Room.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List active rooms\n   * @param names - when undefined or empty, list all rooms.\n   *                otherwise returns rooms with matching names\n   * @returns\n   */\n  async listRooms(names?: string[]): Promise<Room[]> {\n    const data = await this.rpc.request(\n      svc,\n      'ListRooms',\n      new ListRoomsRequest({ names: names ?? [] }).toJson(),\n      await this.authHeader({ roomList: true }),\n    );\n    const res = ListRoomsResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.rooms ?? [];\n  }\n\n  async deleteRoom(room: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'DeleteRoom',\n      new DeleteRoomRequest({ room }).toJson(),\n      await this.authHeader({ roomCreate: true }),\n    );\n  }\n\n  /**\n   * Update metadata of a room\n   * @param room - name of the room\n   * @param metadata - the new metadata for the room\n   */\n  async updateRoomMetadata(room: string, metadata: string) {\n    const data = await this.rpc.request(\n      svc,\n      'UpdateRoomMetadata',\n      new UpdateRoomMetadataRequest({ room, metadata }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    return Room.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List participants in a room\n   * @param room - name of the room\n   */\n  async listParticipants(room: string): Promise<ParticipantInfo[]> {\n    const data = await this.rpc.request(\n      svc,\n      'ListParticipants',\n      new ListParticipantsRequest({ room }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    const res = ListParticipantsResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.participants ?? [];\n  }\n\n  /**\n   * Get information on a specific participant, including the tracks that participant\n   * has published\n   * @param room - name of the room\n   * @param identity - identity of the participant to return\n   */\n  async getParticipant(room: string, identity: string): Promise<ParticipantInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'GetParticipant',\n      new RoomParticipantIdentity({ room, identity }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n\n    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Removes a participant in the room. This will disconnect the participant\n   * and will emit a Disconnected event for that participant.\n   * Even after being removed, the participant can still re-join the room.\n   * @param room -\n   * @param identity -\n   */\n  async removeParticipant(room: string, identity: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'RemoveParticipant',\n      new RoomParticipantIdentity({ room, identity }).toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n\n  /**\n   * Forwards a participant's track to another room. This will create a\n   * participant to join the destination room that has same information\n   * with the source participant except the kind to be `Forwarded`. All\n   * changes to the source participant will be reflected to the forwarded\n   * participant. When the source participant disconnects or the\n   * `RemoveParticipant` method is called in the destination room, the\n   * forwarding will be stopped.\n   * @param room -\n   * @param identity -\n   * @param destinationRoom - the room to forward the participant to\n   */\n  async forwardParticipant(room: string, identity: string, destinationRoom: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'ForwardParticipant',\n      new ForwardParticipantRequest({ room, identity, destinationRoom }).toJson(),\n      await this.authHeader({ roomAdmin: true, room, destinationRoom }),\n    );\n  }\n\n  /**\n   * Move a connected participant to a different room. Requires `roomAdmin` and `destinationRoom`.\n   * The participant will be removed from the current room and added to the destination room.\n   * From the other observers' perspective, the participant would've disconnected from the previous room and joined the new one.\n   * @param room -\n   * @param identity -\n   * @param destinationRoom - the room to move the participant to\n   */\n  async moveParticipant(room: string, identity: string, destinationRoom: string): Promise<void> {\n    await this.rpc.request(\n      svc,\n      'MoveParticipant',\n      new MoveParticipantRequest({ room, identity, destinationRoom }).toJson(),\n      await this.authHeader({ roomAdmin: true, room, destinationRoom }),\n    );\n  }\n\n  /**\n   * Mutes a track that the participant has published.\n   * @param room -\n   * @param identity -\n   * @param trackSid - sid of the track to be muted\n   * @param muted - true to mute, false to unmute\n   */\n  async mutePublishedTrack(\n    room: string,\n    identity: string,\n    trackSid: string,\n    muted: boolean,\n  ): Promise<TrackInfo> {\n    const req = new MuteRoomTrackRequest({\n      room,\n      identity,\n      trackSid,\n      muted,\n    }).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'MutePublishedTrack',\n      req,\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    const res = MuteRoomTrackResponse.fromJson(data, { ignoreUnknownFields: true });\n    return res.track!;\n  }\n\n  /**\n   * Updates a participant's state or permissions\n   * @param room - target room\n   * @param identity - participant identity\n   * @param options - participant fields to update\n   */\n  async updateParticipant(\n    room: string,\n    identity: string,\n    options: UpdateParticipantOptions,\n  ): Promise<ParticipantInfo>;\n  /**\n   * Updates a participant's state or permissions\n   * @param room - target room\n   * @param identity - participant identity\n   * @param options - participant fields to update\n   */\n  async updateParticipant(\n    room: string,\n    identity: string,\n    metadata?: string,\n    permission?: Partial<ParticipantPermission>,\n    name?: string,\n  ): Promise<ParticipantInfo>;\n  async updateParticipant(\n    room: string,\n    identity: string,\n    metadataOrOptions?: string | UpdateParticipantOptions,\n    maybePermission?: Partial<ParticipantPermission>,\n    maybeName?: string,\n  ): Promise<ParticipantInfo> {\n    const hasOptions = typeof metadataOrOptions === 'object';\n    const metadata = hasOptions ? metadataOrOptions?.metadata : metadataOrOptions;\n    const permission = hasOptions ? metadataOrOptions.permission : maybePermission;\n    const name = hasOptions ? metadataOrOptions.name : maybeName;\n    const attributes: Record<string, string> | undefined = hasOptions\n      ? metadataOrOptions.attributes\n      : {};\n\n    const req = new UpdateParticipantRequest({\n      room,\n      identity,\n      attributes,\n      metadata,\n      name,\n    });\n    if (permission) {\n      req.permission = new ParticipantPermission(permission);\n    }\n    const data = await this.rpc.request(\n      svc,\n      'UpdateParticipant',\n      req.toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n    return ParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates a participant's subscription to tracks\n   * @param room -\n   * @param identity -\n   * @param trackSids -\n   * @param subscribe - true to subscribe, false to unsubscribe\n   */\n  async updateSubscriptions(\n    room: string,\n    identity: string,\n    trackSids: string[],\n    subscribe: boolean,\n  ): Promise<void> {\n    const req = new UpdateSubscriptionsRequest({\n      room,\n      identity,\n      trackSids,\n      subscribe,\n      participantTracks: [],\n    }).toJson();\n    await this.rpc.request(\n      svc,\n      'UpdateSubscriptions',\n      req,\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n\n  /**\n   * Sends data message to participants in the room\n   * @param room -\n   * @param data - opaque payload to send\n   * @param kind - delivery reliability\n   * @param options - optionally specify a topic and destinationSids (when destinationSids is empty, message is sent to everyone)\n   */\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    options: SendDataOptions,\n  ): Promise<void>;\n  /**\n   * Sends data message to participants in the room\n   * @deprecated use sendData(room, data, kind, options) instead\n   * @param room -\n   * @param data - opaque payload to send\n   * @param kind - delivery reliability\n   * @param destinationSids - optional. when empty, message is sent to everyone\n   */\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    destinationSids?: string[],\n  ): Promise<void>;\n  async sendData(\n    room: string,\n    data: Uint8Array,\n    kind: DataPacket_Kind,\n    options: SendDataOptions | string[] = {},\n  ): Promise<void> {\n    const destinationSids = Array.isArray(options) ? options : options.destinationSids;\n    const topic = Array.isArray(options) ? undefined : options.topic;\n    const req = new SendDataRequest({\n      room,\n      data,\n      kind,\n      destinationSids: destinationSids ?? [],\n      topic,\n    });\n    if (!Array.isArray(options) && options.destinationIdentities) {\n      req.destinationIdentities = options.destinationIdentities;\n    }\n    req.nonce = await getRandomBytes(16);\n    await this.rpc.request(\n      svc,\n      'SendData',\n      req.toJson(),\n      await this.authHeader({ roomAdmin: true, room }),\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3168, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/SipClient.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport { Duration } from '@bufbuild/protobuf';\nimport type {\n  ListUpdate,\n  Pagination,\n  RoomConfiguration,\n  SIPHeaderOptions,\n} from '@livekit/protocol';\nimport {\n  CreateSIPDispatchRuleRequest,\n  CreateSIPInboundTrunkRequest,\n  CreateSIPOutboundTrunkRequest,\n  CreateSIPParticipantRequest,\n  CreateSIPTrunkRequest,\n  DeleteSIPDispatchRuleRequest,\n  DeleteSIPTrunkRequest,\n  ListSIPDispatchRuleRequest,\n  ListSIPDispatchRuleResponse,\n  ListSIPInboundTrunkRequest,\n  ListSIPInboundTrunkResponse,\n  ListSIPOutboundTrunkRequest,\n  ListSIPOutboundTrunkResponse,\n  ListSIPTrunkRequest,\n  ListSIPTrunkResponse,\n  SIPDispatchRule,\n  SIPDispatchRuleDirect,\n  SIPDispatchRuleIndividual,\n  SIPDispatchRuleInfo,\n  SIPInboundTrunkInfo,\n  SIPOutboundTrunkInfo,\n  SIPParticipantInfo,\n  SIPTransport,\n  SIPTrunkInfo,\n  TransferSIPParticipantRequest,\n  UpdateSIPDispatchRuleRequest,\n  UpdateSIPInboundTrunkRequest,\n  UpdateSIPOutboundTrunkRequest,\n} from '@livekit/protocol';\nimport { ServiceBase } from './ServiceBase.js';\nimport type { Rpc } from './TwirpRPC.js';\nimport { TwirpRpc, livekitPackage } from './TwirpRPC.js';\n\nconst svc = 'SIP';\n\n/**\n * @deprecated use CreateSipInboundTrunkOptions or CreateSipOutboundTrunkOptions\n */\nexport interface CreateSipTrunkOptions {\n  name?: string;\n  metadata?: string;\n  inbound_addresses?: string[];\n  inbound_numbers?: string[];\n  inbound_username?: string;\n  inbound_password?: string;\n  outbound_address?: string;\n  outbound_username?: string;\n  outbound_password?: string;\n}\nexport interface CreateSipInboundTrunkOptions {\n  metadata?: string;\n  /** @deprecated - use `allowedAddresses` instead */\n  allowed_addresses?: string[];\n  allowedAddresses?: string[];\n  /** @deprecated - use `allowedNumbers` instead */\n  allowed_numbers?: string[];\n  allowedNumbers?: string[];\n  /** @deprecated - use `authUsername` instead */\n  auth_username?: string;\n  authUsername?: string;\n  /** @deprecated - use `authPassword` instead */\n  auth_password?: string;\n  authPassword?: string;\n  headers?: { [key: string]: string };\n  headersToAttributes?: { [key: string]: string };\n  // Map SIP response headers from INVITE to sip.h.* participant attributes automatically.\n  includeHeaders?: SIPHeaderOptions;\n  krispEnabled?: boolean;\n}\nexport interface CreateSipOutboundTrunkOptions {\n  metadata?: string;\n  transport: SIPTransport;\n  destinationCountry?: string;\n  /** @deprecated - use `authUsername` instead */\n  auth_username?: string;\n  authUsername?: string;\n  /** @deprecated - use `authPassword` instead */\n  auth_password?: string;\n  authPassword?: string;\n  headers?: { [key: string]: string };\n  headersToAttributes?: { [key: string]: string };\n  // Map SIP response headers from INVITE to sip.h.* participant attributes automatically.\n  includeHeaders?: SIPHeaderOptions;\n}\n\nexport interface SipDispatchRuleDirect {\n  type: 'direct';\n  roomName: string;\n  pin?: string;\n}\n\nexport interface SipDispatchRuleIndividual {\n  type: 'individual';\n  roomPrefix: string;\n  pin?: string;\n}\n\nexport interface CreateSipDispatchRuleOptions {\n  name?: string;\n  metadata?: string;\n  trunkIds?: string[];\n  hidePhoneNumber?: boolean;\n  attributes?: { [key: string]: string };\n  roomPreset?: string;\n  roomConfig?: RoomConfiguration;\n}\n\nexport interface CreateSipParticipantOptions {\n  /** Optional SIP From number to use. If empty, trunk number is used. */\n  fromNumber?: string;\n  /** Optional identity of the SIP participant */\n  participantIdentity?: string;\n  /** Optional name of the participant */\n  participantName?: string;\n  /** Optional metadata to attach to the participant */\n  participantMetadata?: string;\n  /** Optional attributes to attach to the participant */\n  participantAttributes?: { [key: string]: string };\n  /** Optionally send following DTMF digits (extension codes) when making a call.\n   * Character 'w' can be used to add a 0.5 sec delay. */\n  dtmf?: string;\n  /** @deprecated use `playDialtone` instead */\n  playRingtone?: boolean;\n  /** If `true`, the SIP Participant plays a dial tone to the room until the phone is picked up. */\n  playDialtone?: boolean;\n  /** These headers are sent as-is and may help identify this call as coming from LiveKit for the other SIP endpoint. */\n  headers?: { [key: string]: string };\n  /** Map SIP response headers from INVITE to sip.h.* participant attributes automatically. */\n  includeHeaders?: SIPHeaderOptions;\n  hidePhoneNumber?: boolean;\n  /** Maximum time for the call to ring in seconds. */\n  ringingTimeout?: number;\n  /** Maximum call duration in seconds. */\n  maxCallDuration?: number;\n  /** If `true`, Krisp noise cancellation will be enabled for the caller. */\n  krispEnabled?: boolean;\n  /** If `true`, this will wait until the call is answered before returning. */\n  waitUntilAnswered?: boolean;\n  /** Optional request timeout in seconds. default 60 seconds if waitUntilAnswered is true, otherwise 10 seconds */\n  timeout?: number;\n}\n\nexport interface ListSipDispatchRuleOptions {\n  /** Pagination options. */\n  page?: Pagination;\n  /** Rule IDs to list. If this option is set, the response will contains rules in the same order. If any of the rules is missing, a nil item in that position will be sent in the response. */\n  dispatchRuleIds?: string[];\n  /** Only list rules that contain one of the Trunk IDs, including wildcard rules. */\n  trunkIds?: string[];\n}\n\nexport interface ListSipTrunkOptions {\n  /** Pagination options. */\n  page?: Pagination;\n  /** Trunk IDs to list. If this option is set, the response will contains trunks in the same order. If any of the trunks is missing, a nil item in that position will be sent in the response. */\n  trunkIds?: string[];\n  /** Only list trunks that contain one of the numbers, including wildcard trunks. */\n  numbers?: string[];\n}\n\nexport interface SipDispatchRuleUpdateOptions {\n  trunkIds?: ListUpdate;\n  rule?: SIPDispatchRule;\n  name?: string;\n  metadata?: string;\n  attributes?: { [key: string]: string };\n}\n\nexport interface SipInboundTrunkUpdateOptions {\n  numbers?: ListUpdate;\n  allowedAddresses?: ListUpdate;\n  allowedNumbers?: ListUpdate;\n  authUsername?: string;\n  authPassword?: string;\n  name?: string;\n  metadata?: string;\n}\n\nexport interface SipOutboundTrunkUpdateOptions {\n  numbers?: ListUpdate;\n  allowedAddresses?: ListUpdate;\n  allowedNumbers?: ListUpdate;\n  authUsername?: string;\n  authPassword?: string;\n  destinationCountry?: string;\n  name?: string;\n  metadata?: string;\n}\n\nexport interface TransferSipParticipantOptions {\n  playDialtone?: boolean;\n  headers?: { [key: string]: string };\n}\n\n/**\n * Client to access Egress APIs\n */\nexport class SipClient extends ServiceBase {\n  private readonly rpc: Rpc;\n\n  /**\n   * @param host - hostname including protocol. i.e. 'https://<project>.livekit.cloud'\n   * @param apiKey - API Key, can be set in env var LIVEKIT_API_KEY\n   * @param secret - API Secret, can be set in env var LIVEKIT_API_SECRET\n   */\n  constructor(host: string, apiKey?: string, secret?: string) {\n    super(apiKey, secret);\n    this.rpc = new TwirpRpc(host, livekitPackage);\n  }\n\n  /**\n   * @param number - phone number of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @deprecated use `createSipInboundTrunk` or `createSipOutboundTrunk`\n   */\n  async createSipTrunk(number: string, opts?: CreateSipTrunkOptions): Promise<SIPTrunkInfo> {\n    let inboundAddresses: string[] | undefined;\n    let inboundNumbers: string[] | undefined;\n    let inboundUsername: string = '';\n    let inboundPassword: string = '';\n    let outboundAddress: string = '';\n    let outboundUsername: string = '';\n    let outboundPassword: string = '';\n    let name: string = '';\n    let metadata: string = '';\n\n    if (opts !== undefined) {\n      inboundAddresses = opts.inbound_addresses;\n      inboundNumbers = opts.inbound_numbers;\n      inboundUsername = opts.inbound_username || '';\n      inboundPassword = opts.inbound_password || '';\n      outboundAddress = opts.outbound_address || '';\n      outboundUsername = opts.outbound_username || '';\n      outboundPassword = opts.outbound_password || '';\n      name = opts.name || '';\n      metadata = opts.metadata || '';\n    }\n\n    const req = new CreateSIPTrunkRequest({\n      name: name,\n      metadata: metadata,\n      inboundAddresses: inboundAddresses,\n      inboundNumbers: inboundNumbers,\n      inboundUsername: inboundUsername,\n      inboundPassword: inboundPassword,\n      outboundNumber: number,\n      outboundAddress: outboundAddress,\n      outboundUsername: outboundUsername,\n      outboundPassword: outboundPassword,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP inbound trunk.\n   *\n   * @param name - human-readable name of the trunk\n   * @param numbers - phone numbers of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @returns Created SIP inbound trunk\n   */\n  async createSipInboundTrunk(\n    name: string,\n    numbers: string[],\n    opts?: CreateSipInboundTrunkOptions,\n  ): Promise<SIPInboundTrunkInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n    const req = new CreateSIPInboundTrunkRequest({\n      trunk: new SIPInboundTrunkInfo({\n        name: name,\n        numbers: numbers,\n        metadata: opts?.metadata,\n        allowedAddresses: opts.allowedAddresses ?? opts.allowed_addresses,\n        allowedNumbers: opts.allowedNumbers ?? opts.allowed_numbers,\n        authUsername: opts.authUsername ?? opts.auth_username,\n        authPassword: opts.authPassword ?? opts.auth_password,\n        headers: opts.headers,\n        headersToAttributes: opts.headersToAttributes,\n        includeHeaders: opts.includeHeaders,\n        krispEnabled: opts.krispEnabled,\n      }),\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP outbound trunk.\n   *\n   * @param name - human-readable name of the trunk\n   * @param address - hostname and port of the SIP server to dial\n   * @param numbers - phone numbers of the trunk\n   * @param opts - CreateSipTrunkOptions\n   * @returns Created SIP outbound trunk\n   */\n  async createSipOutboundTrunk(\n    name: string,\n    address: string,\n    numbers: string[],\n    opts?: CreateSipOutboundTrunkOptions,\n  ): Promise<SIPOutboundTrunkInfo> {\n    if (opts === undefined) {\n      opts = {\n        transport: SIPTransport.SIP_TRANSPORT_AUTO,\n      };\n    }\n\n    const req = new CreateSIPOutboundTrunkRequest({\n      trunk: new SIPOutboundTrunkInfo({\n        name: name,\n        address: address,\n        numbers: numbers,\n        metadata: opts.metadata,\n        transport: opts.transport,\n        authUsername: opts.authUsername ?? opts.auth_username,\n        authPassword: opts.authPassword ?? opts.auth_password,\n        headers: opts.headers,\n        headersToAttributes: opts.headersToAttributes,\n        includeHeaders: opts.includeHeaders,\n        destinationCountry: opts.destinationCountry,\n      }),\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * @deprecated use `listSipInboundTrunk` or `listSipOutboundTrunk`\n   */\n  async listSipTrunk(): Promise<Array<SIPTrunkInfo>> {\n    const req: Partial<ListSIPTrunkRequest> = {};\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPTrunk',\n      new ListSIPTrunkRequest(req).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * List SIP inbound trunks with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP inbound trunks\n   */\n  async listSipInboundTrunk(list: ListSipTrunkOptions = {}): Promise<Array<SIPInboundTrunkInfo>> {\n    const req = new ListSIPInboundTrunkRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPInboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * List SIP outbound trunks with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP outbound trunks\n   */\n  async listSipOutboundTrunk(list: ListSipTrunkOptions = {}): Promise<Array<SIPOutboundTrunkInfo>> {\n    const req = new ListSIPOutboundTrunkRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPOutboundTrunkResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * Delete a SIP trunk.\n   *\n   * @param sipTrunkId - ID of the SIP trunk to delete\n   * @returns Deleted trunk information\n   */\n  async deleteSipTrunk(sipTrunkId: string): Promise<SIPTrunkInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteSIPTrunk',\n      new DeleteSIPTrunkRequest({ sipTrunkId }).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP dispatch rule.\n   *\n   * @param rule - SIP dispatch rule to create\n   * @param opts - CreateSipDispatchRuleOptions\n   * @returns Created SIP dispatch rule\n   */\n  async createSipDispatchRule(\n    rule: SipDispatchRuleDirect | SipDispatchRuleIndividual,\n    opts?: CreateSipDispatchRuleOptions,\n  ): Promise<SIPDispatchRuleInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n    let ruleProto: SIPDispatchRule | undefined = undefined;\n    if (rule.type == 'direct') {\n      ruleProto = new SIPDispatchRule({\n        rule: {\n          case: 'dispatchRuleDirect',\n          value: new SIPDispatchRuleDirect({\n            roomName: rule.roomName,\n            pin: rule.pin || '',\n          }),\n        },\n      });\n    } else if (rule.type == 'individual') {\n      ruleProto = new SIPDispatchRule({\n        rule: {\n          case: 'dispatchRuleIndividual',\n          value: new SIPDispatchRuleIndividual({\n            roomPrefix: rule.roomPrefix,\n            pin: rule.pin || '',\n          }),\n        },\n      });\n    }\n\n    const req = new CreateSIPDispatchRuleRequest({\n      rule: ruleProto,\n      trunkIds: opts.trunkIds,\n      hidePhoneNumber: opts.hidePhoneNumber,\n      name: opts.name,\n      metadata: opts.metadata,\n      attributes: opts.attributes,\n      roomPreset: opts.roomPreset,\n      roomConfig: opts.roomConfig,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP dispatch rule by replacing it entirely.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to update\n   * @param rule - new SIP dispatch rule\n   * @returns Updated SIP dispatch rule\n   */\n  async updateSipDispatchRule(\n    sipDispatchRuleId: string,\n    rule: SIPDispatchRuleInfo,\n  ): Promise<SIPDispatchRuleInfo> {\n    const req = new UpdateSIPDispatchRuleRequest({\n      sipDispatchRuleId: sipDispatchRuleId,\n      action: {\n        case: 'replace',\n        value: rule,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP dispatch rule.\n   * Only provided fields will be updated.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to update\n   * @param fields - Fields of the dispatch rule to update\n   * @returns Updated SIP dispatch rule\n   */\n  async updateSipDispatchRuleFields(\n    sipDispatchRuleId: string,\n    fields: SipDispatchRuleUpdateOptions = {},\n  ): Promise<SIPDispatchRuleInfo> {\n    const req = new UpdateSIPDispatchRuleRequest({\n      sipDispatchRuleId: sipDispatchRuleId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP inbound trunk by replacing it entirely.\n   *\n   * @param sipTrunkId - ID of the SIP inbound trunk to update\n   * @param trunk - SIP inbound trunk to update with\n   * @returns Updated SIP inbound trunk\n   */\n  async updateSipInboundTrunk(\n    sipTrunkId: string,\n    trunk: SIPInboundTrunkInfo,\n  ): Promise<SIPInboundTrunkInfo> {\n    const req = new UpdateSIPInboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'replace',\n        value: trunk,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP inbound trunk.\n   * Only provided fields will be updated.\n   *\n   * @param sipTrunkId - ID of the SIP inbound trunk to update\n   * @param fields - Fields of the inbound trunk to update\n   * @returns Updated SIP inbound trunk\n   */\n  async updateSipInboundTrunkFields(\n    sipTrunkId: string,\n    fields: SipInboundTrunkUpdateOptions,\n  ): Promise<SIPInboundTrunkInfo> {\n    const req = new UpdateSIPInboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPInboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPInboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates an existing SIP outbound trunk by replacing it entirely.\n   *\n   * @param sipTrunkId - ID of the SIP outbound trunk to update\n   * @param trunk - SIP outbound trunk to update with\n   * @returns Updated SIP outbound trunk\n   */\n  async updateSipOutboundTrunk(\n    sipTrunkId: string,\n    trunk: SIPOutboundTrunkInfo,\n  ): Promise<SIPOutboundTrunkInfo> {\n    const req = new UpdateSIPOutboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'replace',\n        value: trunk,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Updates specific fields of an existing SIP outbound trunk.\n   * Only provided fields will be updated.\n   *\n   * @param sipTrunkId - ID of the SIP outbound trunk to update\n   * @param fields - Fields of the outbound trunk to update\n   * @returns Updated SIP outbound trunk\n   */\n  async updateSipOutboundTrunkFields(\n    sipTrunkId: string,\n    fields: SipOutboundTrunkUpdateOptions,\n  ): Promise<SIPOutboundTrunkInfo> {\n    const req = new UpdateSIPOutboundTrunkRequest({\n      sipTrunkId,\n      action: {\n        case: 'update',\n        value: fields,\n      },\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'UpdateSIPOutboundTrunk',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n\n    return SIPOutboundTrunkInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * List SIP dispatch rules with optional filtering.\n   *\n   * @param list - Request with optional filtering parameters\n   * @returns Response containing list of SIP dispatch rules\n   */\n  async listSipDispatchRule(\n    list: ListSipDispatchRuleOptions = {},\n  ): Promise<Array<SIPDispatchRuleInfo>> {\n    const req = new ListSIPDispatchRuleRequest(list).toJson();\n    const data = await this.rpc.request(\n      svc,\n      'ListSIPDispatchRule',\n      req,\n      await this.authHeader({}, { admin: true }),\n    );\n    return ListSIPDispatchRuleResponse.fromJson(data, { ignoreUnknownFields: true }).items ?? [];\n  }\n\n  /**\n   * Delete a SIP dispatch rule.\n   *\n   * @param sipDispatchRuleId - ID of the SIP dispatch rule to delete\n   * @returns Deleted rule information\n   */\n  async deleteSipDispatchRule(sipDispatchRuleId: string): Promise<SIPDispatchRuleInfo> {\n    const data = await this.rpc.request(\n      svc,\n      'DeleteSIPDispatchRule',\n      new DeleteSIPDispatchRuleRequest({ sipDispatchRuleId }).toJson(),\n      await this.authHeader({}, { admin: true }),\n    );\n    return SIPDispatchRuleInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Create a new SIP participant.\n   *\n   * @param sipTrunkId - sip trunk to use for the call\n   * @param number - number to dial\n   * @param roomName - room to attach the call to\n   * @param opts - CreateSipParticipantOptions\n   * @returns Created SIP participant\n   */\n  async createSipParticipant(\n    sipTrunkId: string,\n    number: string,\n    roomName: string,\n    opts?: CreateSipParticipantOptions,\n  ): Promise<SIPParticipantInfo> {\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    if (opts.timeout === undefined) {\n      opts.timeout = opts.waitUntilAnswered ? 60 : 10;\n    }\n\n    const req = new CreateSIPParticipantRequest({\n      sipTrunkId: sipTrunkId,\n      sipCallTo: number,\n      sipNumber: opts.fromNumber,\n      roomName: roomName,\n      participantIdentity: opts.participantIdentity || 'sip-participant',\n      participantName: opts.participantName,\n      participantMetadata: opts.participantMetadata,\n      participantAttributes: opts.participantAttributes,\n      dtmf: opts.dtmf,\n      playDialtone: opts.playDialtone ?? opts.playRingtone,\n      headers: opts.headers,\n      hidePhoneNumber: opts.hidePhoneNumber,\n      includeHeaders: opts.includeHeaders,\n      ringingTimeout: opts.ringingTimeout\n        ? new Duration({ seconds: BigInt(opts.ringingTimeout) })\n        : undefined,\n      maxCallDuration: opts.maxCallDuration\n        ? new Duration({ seconds: BigInt(opts.maxCallDuration) })\n        : undefined,\n      krispEnabled: opts.krispEnabled,\n      waitUntilAnswered: opts.waitUntilAnswered,\n    }).toJson();\n\n    const data = await this.rpc.request(\n      svc,\n      'CreateSIPParticipant',\n      req,\n      await this.authHeader({}, { call: true }),\n      opts.timeout,\n    );\n    return SIPParticipantInfo.fromJson(data, { ignoreUnknownFields: true });\n  }\n\n  /**\n   * Transfer a SIP participant to a different room.\n   *\n   * @param roomName - room the SIP participant to transfer is connectd to\n   * @param participantIdentity - identity of the SIP participant to transfer\n   * @param transferTo - SIP URL to transfer the participant to\n   * @param opts - TransferSipParticipantOptions\n   */\n  async transferSipParticipant(\n    roomName: string,\n    participantIdentity: string,\n    transferTo: string,\n    opts?: TransferSipParticipantOptions,\n  ): Promise<void> {\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    const req = new TransferSIPParticipantRequest({\n      participantIdentity: participantIdentity,\n      roomName: roomName,\n      transferTo: transferTo,\n      playDialtone: opts.playDialtone,\n      headers: opts.headers,\n    }).toJson();\n\n    await this.rpc.request(\n      svc,\n      'TransferSIPParticipant',\n      req,\n      await this.authHeader({ roomAdmin: true, room: roomName }, { call: true }),\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAGA,SAAS,gBAAgB;AAOzB;AA8BA,SAAS,mBAAmB;AAE5B,SAAS,UAAU,sBAAsB;;;;;AAEzC,MAAM,MAAM;AAoKL,MAAM,kBAAkB,gLAAA,CAAY;IAAA;;;;GAAA,GAQzC,YAAY,IAAA,EAAc,MAAA,EAAiB,MAAA,CAAiB;QAC1D,KAAA,CAAM,QAAQ,MAAM;QACpB,IAAA,CAAK,GAAA,GAAM,IAAI,0KAAA,CAAS,MAAM,gLAAc;IAC9C;IAAA;;;;GAAA,GAOA,MAAM,eAAe,MAAA,EAAgB,IAAA,EAAqD;QACxF,IAAI;QACJ,IAAI;QACJ,IAAI,kBAA0B;QAC9B,IAAI,kBAA0B;QAC9B,IAAI,kBAA0B;QAC9B,IAAI,mBAA2B;QAC/B,IAAI,mBAA2B;QAC/B,IAAI,OAAe;QACnB,IAAI,WAAmB;QAEvB,IAAI,SAAS,KAAA,GAAW;YACtB,mBAAmB,KAAK,iBAAA;YACxB,iBAAiB,KAAK,eAAA;YACtB,kBAAkB,KAAK,gBAAA,IAAoB;YAC3C,kBAAkB,KAAK,gBAAA,IAAoB;YAC3C,kBAAkB,KAAK,gBAAA,IAAoB;YAC3C,mBAAmB,KAAK,iBAAA,IAAqB;YAC7C,mBAAmB,KAAK,iBAAA,IAAqB;YAC7C,OAAO,KAAK,IAAA,IAAQ;YACpB,WAAW,KAAK,QAAA,IAAY;QAC9B;QAEA,MAAM,MAAM,IAAI,kMAAA,CAAsB;YACpC;YACA;YACA;YACA;YACA;YACA;YACA,gBAAgB;YAChB;YACA;YACA;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,kBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,yLAAA,CAAa,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IAClE;IAAA;;;;;;;GAAA,GAUA,MAAM,sBACJ,IAAA,EACA,OAAA,EACA,IAAA,EAC8B;QAC9B,IAAI,SAAS,KAAA,GAAW;YACtB,OAAO,CAAC;QACV;QACA,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C,OAAO,IAAI,gMAAA,CAAoB;gBAC7B;gBACA;gBACA,UAAU,QAAA,OAAA,KAAA,IAAA,KAAM,QAAA;gBAChB,kBAAkB,KAAK,gBAAA,IAAoB,KAAK,iBAAA;gBAChD,gBAAgB,KAAK,cAAA,IAAkB,KAAK,eAAA;gBAC5C,cAAc,KAAK,YAAA,IAAgB,KAAK,aAAA;gBACxC,cAAc,KAAK,YAAA,IAAgB,KAAK,aAAA;gBACxC,SAAS,KAAK,OAAA;gBACd,qBAAqB,KAAK,mBAAA;gBAC1B,gBAAgB,KAAK,cAAA;gBACrB,cAAc,KAAK,YAAA;YACrB,CAAC;QACH,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;;;GAAA,GAWA,MAAM,uBACJ,IAAA,EACA,OAAA,EACA,OAAA,EACA,IAAA,EAC+B;QAC/B,IAAI,SAAS,KAAA,GAAW;YACtB,OAAO;gBACL,WAAW,yLAAA,CAAa,kBAAA;YAC1B;QACF;QAEA,MAAM,MAAM,IAAI,0MAAA,CAA8B;YAC5C,OAAO,IAAI,iMAAA,CAAqB;gBAC9B;gBACA;gBACA;gBACA,UAAU,KAAK,QAAA;gBACf,WAAW,KAAK,SAAA;gBAChB,cAAc,KAAK,YAAA,IAAgB,KAAK,aAAA;gBACxC,cAAc,KAAK,YAAA,IAAgB,KAAK,aAAA;gBACxC,SAAS,KAAK,OAAA;gBACd,qBAAqB,KAAK,mBAAA;gBAC1B,gBAAgB,KAAK,cAAA;gBACrB,oBAAoB,KAAK,kBAAA;YAC3B,CAAC;QACH,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,0BACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,iMAAA,CAAqB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IAC1E;IAAA;;GAAA,GAKA,MAAM,eAA6C;QACjD,MAAM,MAAoC,CAAC;QAC3C,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,gBACA,IAAI,gMAAA,CAAoB,GAAG,EAAE,MAAA,CAAO,GACpC,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,iMAAA,CAAqB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC,EAAE,KAAA,IAAS,CAAC,CAAA;IACtF;IAAA;;;;;GAAA,GAQA,MAAM,oBAAoB,OAA4B,CAAC,CAAA,EAAwC;QAC7F,MAAM,MAAM,IAAI,uMAAA,CAA2B,IAAI,EAAE,MAAA,CAAO;QACxD,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,uBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,wMAAA,CAA4B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC,EAAE,KAAA,IAAS,CAAC,CAAA;IAC7F;IAAA;;;;;GAAA,GAQA,MAAM,qBAAqB,OAA4B,CAAC,CAAA,EAAyC;QAC/F,MAAM,MAAM,IAAI,wMAAA,CAA4B,IAAI,EAAE,MAAA,CAAO;QACzD,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,wBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,yMAAA,CAA6B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC,EAAE,KAAA,IAAS,CAAC,CAAA;IAC9F;IAAA;;;;;GAAA,GAQA,MAAM,eAAe,UAAA,EAA2C;QAC9D,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,kBACA,IAAI,kMAAA,CAAsB;YAAE;QAAW,CAAC,EAAE,MAAA,CAAO,GACjD,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,yLAAA,CAAa,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IAClE;IAAA;;;;;;GAAA,GASA,MAAM,sBACJ,IAAA,EACA,IAAA,EAC8B;QAC9B,IAAI,SAAS,KAAA,GAAW;YACtB,OAAO,CAAC;QACV;QACA,IAAI,YAAyC,KAAA;QAC7C,IAAI,KAAK,IAAA,IAAQ,UAAU;YACzB,YAAY,IAAI,4LAAA,CAAgB;gBAC9B,MAAM;oBACJ,MAAM;oBACN,OAAO,IAAI,kMAAA,CAAsB;wBAC/B,UAAU,KAAK,QAAA;wBACf,KAAK,KAAK,GAAA,IAAO;oBACnB,CAAC;gBACH;YACF,CAAC;QACH,OAAA,IAAW,KAAK,IAAA,IAAQ,cAAc;YACpC,YAAY,IAAI,4LAAA,CAAgB;gBAC9B,MAAM;oBACJ,MAAM;oBACN,OAAO,IAAI,sMAAA,CAA0B;wBACnC,YAAY,KAAK,UAAA;wBACjB,KAAK,KAAK,GAAA,IAAO;oBACnB,CAAC;gBACH;YACF,CAAC;QACH;QAEA,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C,MAAM;YACN,UAAU,KAAK,QAAA;YACf,iBAAiB,KAAK,eAAA;YACtB,MAAM,KAAK,IAAA;YACX,UAAU,KAAK,QAAA;YACf,YAAY,KAAK,UAAA;YACjB,YAAY,KAAK,UAAA;YACjB,YAAY,KAAK,UAAA;QACnB,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;GAAA,GASA,MAAM,sBACJ,iBAAA,EACA,IAAA,EAC8B;QAC9B,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;;GAAA,GAUA,MAAM,4BACJ,iBAAA,EACA,SAAuC,CAAC,CAAA,EACV;QAC9B,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;GAAA,GASA,MAAM,sBACJ,UAAA,EACA,KAAA,EAC8B;QAC9B,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;;GAAA,GAUA,MAAM,4BACJ,UAAA,EACA,MAAA,EAC8B;QAC9B,MAAM,MAAM,IAAI,yMAAA,CAA6B;YAC3C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;GAAA,GASA,MAAM,uBACJ,UAAA,EACA,KAAA,EAC+B;QAC/B,MAAM,MAAM,IAAI,0MAAA,CAA8B;YAC5C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,0BACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,iMAAA,CAAqB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IAC1E;IAAA;;;;;;;GAAA,GAUA,MAAM,6BACJ,UAAA,EACA,MAAA,EAC+B;QAC/B,MAAM,MAAM,IAAI,0MAAA,CAA8B;YAC5C;YACA,QAAQ;gBACN,MAAM;gBACN,OAAO;YACT;QACF,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,0BACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAG3C,OAAO,iMAAA,CAAqB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IAC1E;IAAA;;;;;GAAA,GAQA,MAAM,oBACJ,OAAmC,CAAC,CAAA,EACC;QACrC,MAAM,MAAM,IAAI,uMAAA,CAA2B,IAAI,EAAE,MAAA,CAAO;QACxD,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,uBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,wMAAA,CAA4B,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC,EAAE,KAAA,IAAS,CAAC,CAAA;IAC7F;IAAA;;;;;GAAA,GAQA,MAAM,sBAAsB,iBAAA,EAAyD;QACnF,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,yBACA,IAAI,yMAAA,CAA6B;YAAE;QAAkB,CAAC,EAAE,MAAA,CAAO,GAC/D,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,OAAO;QAAK,CAAC;QAE3C,OAAO,gMAAA,CAAoB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACzE;IAAA;;;;;;;;GAAA,GAWA,MAAM,qBACJ,UAAA,EACA,MAAA,EACA,QAAA,EACA,IAAA,EAC6B;QAC7B,IAAI,SAAS,KAAA,GAAW;YACtB,OAAO,CAAC;QACV;QAEA,IAAI,KAAK,OAAA,KAAY,KAAA,GAAW;YAC9B,KAAK,OAAA,GAAU,KAAK,iBAAA,GAAoB,KAAK;QAC/C;QAEA,MAAM,MAAM,IAAI,wMAAA,CAA4B;YAC1C;YACA,WAAW;YACX,WAAW,KAAK,UAAA;YAChB;YACA,qBAAqB,KAAK,mBAAA,IAAuB;YACjD,iBAAiB,KAAK,eAAA;YACtB,qBAAqB,KAAK,mBAAA;YAC1B,uBAAuB,KAAK,qBAAA;YAC5B,MAAM,KAAK,IAAA;YACX,cAAc,KAAK,YAAA,IAAgB,KAAK,YAAA;YACxC,SAAS,KAAK,OAAA;YACd,iBAAiB,KAAK,eAAA;YACtB,gBAAgB,KAAK,cAAA;YACrB,gBAAgB,KAAK,cAAA,GACjB,IAAI,wMAAA,CAAS;gBAAE,SAAS,OAAO,KAAK,cAAc;YAAE,CAAC,IACrD,KAAA;YACJ,iBAAiB,KAAK,eAAA,GAClB,IAAI,wMAAA,CAAS;gBAAE,SAAS,OAAO,KAAK,eAAe;YAAE,CAAC,IACtD,KAAA;YACJ,cAAc,KAAK,YAAA;YACnB,mBAAmB,KAAK,iBAAA;QAC1B,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,OAAO,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CAC1B,KACA,wBACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW,CAAC,GAAG;YAAE,MAAM;QAAK,CAAC,GACxC,KAAK,OAAA;QAEP,OAAO,+LAAA,CAAmB,QAAA,CAAS,MAAM;YAAE,qBAAqB;QAAK,CAAC;IACxE;IAAA;;;;;;;GAAA,GAUA,MAAM,uBACJ,QAAA,EACA,mBAAA,EACA,UAAA,EACA,IAAA,EACe;QACf,IAAI,SAAS,KAAA,GAAW;YACtB,OAAO,CAAC;QACV;QAEA,MAAM,MAAM,IAAI,0MAAA,CAA8B;YAC5C;YACA;YACA;YACA,cAAc,KAAK,YAAA;YACnB,SAAS,KAAK,OAAA;QAChB,CAAC,EAAE,MAAA,CAAO;QAEV,MAAM,IAAA,CAAK,GAAA,CAAI,OAAA,CACb,KACA,0BACA,KACA,MAAM,IAAA,CAAK,UAAA,CAAW;YAAE,WAAW;YAAM,MAAM;QAAS,GAAG;YAAE,MAAM;QAAK,CAAC;IAE7E;AACF","debugId":null}},
    {"offset": {"line": 3641, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/crypto/digest.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\n// Use the Web Crypto API if available, otherwise fallback to Node.js crypto\nexport async function digest(data: string): Promise<ArrayBuffer> {\n  if (globalThis.crypto?.subtle) {\n    const encoder = new TextEncoder();\n    return crypto.subtle.digest('SHA-256', encoder.encode(data));\n  } else {\n    const nodeCrypto = await import('node:crypto');\n    return nodeCrypto.createHash('sha256').update(data).digest();\n  }\n}\n"],"names":[],"mappings":";;;;AAKA,eAAsB,OAAO,IAAA,EAAoC;IALjE,IAAA;IAME,IAAA,CAAI,KAAA,WAAW,MAAA,KAAX,OAAA,KAAA,IAAA,GAAmB,MAAA,EAAQ;QAC7B,MAAM,UAAU,IAAI,YAAY;QAChC,OAAO,OAAO,MAAA,CAAO,MAAA,CAAO,WAAW,QAAQ,MAAA,CAAO,IAAI,CAAC;IAC7D,OAAO;QACL,MAAM,aAAa,MAAM,OAAO,aAAa;QAC7C,OAAO,WAAW,UAAA,CAAW,QAAQ,EAAE,MAAA,CAAO,IAAI,EAAE,MAAA,CAAO;IAC7D;AACF","debugId":null}},
    {"offset": {"line": 3661, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/WebhookReceiver.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\nimport type { BinaryReadOptions, JsonReadOptions, JsonValue } from '@bufbuild/protobuf';\nimport { WebhookEvent as ProtoWebhookEvent } from '@livekit/protocol';\nimport { TokenVerifier } from './AccessToken.js';\nimport { digest } from './crypto/digest.js';\n\nexport const authorizeHeader = 'Authorize';\n\nexport class WebhookEvent extends ProtoWebhookEvent {\n  event: WebhookEventNames = '';\n\n  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromBinary(bytes, options);\n  }\n\n  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromJson(jsonValue, options);\n  }\n\n  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WebhookEvent {\n    return new WebhookEvent().fromJsonString(jsonString, options);\n  }\n}\n\nexport type WebhookEventNames =\n  | 'room_started'\n  | 'room_finished'\n  | 'participant_joined'\n  | 'participant_left'\n  | 'participant_connection_aborted'\n  | 'track_published'\n  | 'track_unpublished'\n  | 'egress_started'\n  | 'egress_updated'\n  | 'egress_ended'\n  | 'ingress_started'\n  | 'ingress_ended'\n  /**\n   * @internal\n   * @remarks only used as a default value, not a valid webhook event\n   */\n  | '';\n\nexport class WebhookReceiver {\n  private verifier: TokenVerifier;\n\n  constructor(apiKey: string, apiSecret: string) {\n    this.verifier = new TokenVerifier(apiKey, apiSecret);\n  }\n\n  /**\n   * @param body - string of the posted body\n   * @param authHeader - `Authorization` header from the request\n   * @param skipAuth - true to skip auth validation\n   * @param clockTolerance - How much tolerance to allow for checks against the auth header to be skewed from the claims\n   * @returns The processed webhook event\n   */\n  async receive(\n    body: string,\n    authHeader?: string,\n    skipAuth: boolean = false,\n    clockTolerance?: string | number,\n  ): Promise<WebhookEvent> {\n    // verify token\n    if (!skipAuth) {\n      if (!authHeader) {\n        throw new Error('authorization header is empty');\n      }\n      const claims = await this.verifier.verify(authHeader, clockTolerance);\n      // confirm sha\n      const hash = await digest(body);\n      const hashDecoded = btoa(\n        Array.from(new Uint8Array(hash))\n          .map((v) => String.fromCharCode(v))\n          .join(''),\n      );\n\n      if (claims.sha256 !== hashDecoded) {\n        throw new Error('sha256 checksum of body does not match');\n      }\n    }\n\n    return WebhookEvent.fromJson(JSON.parse(body), { ignoreUnknownFields: true });\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,SAAS,gBAAgB,yBAAyB;AAClD,SAAS,qBAAqB;AAC9B,SAAS,cAAc;;;;AAEhB,MAAM,kBAAkB;AAExB,MAAM,qBAAqB,yLAAA,CAAkB;IAA7C,aAAA;QAAA,KAAA,IAAA;QACL,IAAA,CAAA,KAAA,GAA2B;IAAA;IAE3B,OAAO,WAAW,KAAA,EAAmB,OAAA,EAAoD;QACvF,OAAO,IAAI,aAAa,EAAE,UAAA,CAAW,OAAO,OAAO;IACrD;IAEA,OAAO,SAAS,SAAA,EAAsB,OAAA,EAAkD;QACtF,OAAO,IAAI,aAAa,EAAE,QAAA,CAAS,WAAW,OAAO;IACvD;IAEA,OAAO,eAAe,UAAA,EAAoB,OAAA,EAAkD;QAC1F,OAAO,IAAI,aAAa,EAAE,cAAA,CAAe,YAAY,OAAO;IAC9D;AACF;AAqBO,MAAM,gBAAgB;IAG3B,YAAY,MAAA,EAAgB,SAAA,CAAmB;QAC7C,IAAA,CAAK,QAAA,GAAW,IAAI,kLAAA,CAAc,QAAQ,SAAS;IACrD;IAAA;;;;;;GAAA,GASA,MAAM,QACJ,IAAA,EACA,UAAA,EACA,WAAoB,KAAA,EACpB,cAAA,EACuB;QAEvB,IAAI,CAAC,UAAU;YACb,IAAI,CAAC,YAAY;gBACf,MAAM,IAAI,MAAM,+BAA+B;YACjD;YACA,MAAM,SAAS,MAAM,IAAA,CAAK,QAAA,CAAS,MAAA,CAAO,YAAY,cAAc;YAEpE,MAAM,OAAO,UAAM,gLAAA,EAAO,IAAI;YAC9B,MAAM,cAAc,KAClB,MAAM,IAAA,CAAK,IAAI,WAAW,IAAI,CAAC,EAC5B,GAAA,CAAI,CAAC,IAAM,OAAO,YAAA,CAAa,CAAC,CAAC,EACjC,IAAA,CAAK,EAAE;YAGZ,IAAI,OAAO,MAAA,KAAW,aAAa;gBACjC,MAAM,IAAI,MAAM,wCAAwC;YAC1D;QACF;QAEA,OAAO,aAAa,QAAA,CAAS,KAAK,KAAA,CAAM,IAAI,GAAG;YAAE,qBAAqB;QAAK,CAAC;IAC9E;AACF","debugId":null}},
    {"offset": {"line": 3724, "column": 0}, "map": {"version":3,"sources":["file:///Users/ashutosh/Attack%20Capital/assignment/frontend/node_modules/livekit-server-sdk/src/index.ts"],"sourcesContent":["// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n\nexport {\n  AliOSSUpload,\n  AudioCodec,\n  AutoParticipantEgress,\n  AutoTrackEgress,\n  AzureBlobUpload,\n  DataPacket_Kind,\n  DirectFileOutput,\n  EgressInfo,\n  EgressStatus,\n  EncodedFileOutput,\n  EncodedFileType,\n  EncodingOptions,\n  EncodingOptionsPreset,\n  GCPUpload,\n  ImageCodec,\n  ImageFileSuffix,\n  ImageOutput,\n  IngressAudioEncodingOptions,\n  IngressAudioEncodingPreset,\n  IngressAudioOptions,\n  IngressInfo,\n  IngressInput,\n  IngressState,\n  IngressVideoEncodingOptions,\n  IngressVideoEncodingPreset,\n  IngressVideoOptions,\n  ParticipantEgressRequest,\n  ParticipantInfo,\n  ParticipantInfo_State,\n  ParticipantPermission,\n  Room,\n  RoomCompositeEgressRequest,\n  RoomEgress,\n  S3Upload,\n  SIPDispatchRuleInfo,\n  SIPParticipantInfo,\n  SIPTrunkInfo,\n  SegmentedFileOutput,\n  SegmentedFileProtocol,\n  StreamOutput,\n  StreamProtocol,\n  TrackCompositeEgressRequest,\n  TrackEgressRequest,\n  TrackInfo,\n  TrackSource,\n  TrackType,\n  WebEgressRequest,\n  VideoCodec,\n  WebhookConfig,\n} from '@livekit/protocol';\nexport * from './AccessToken.js';\nexport * from './AgentDispatchClient.js';\nexport * from './EgressClient.js';\nexport * from './grants.js';\nexport * from './IngressClient.js';\nexport * from './RoomServiceClient.js';\nexport * from './SipClient.js';\nexport * from './WebhookReceiver.js';\n"],"names":[],"mappings":";AAIA;AAmDA,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc","debugId":null}}]
}